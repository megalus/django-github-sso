{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Intro","text":""},{"location":"#welcome-to-django-github-sso","title":"Welcome to Django GitHub SSO","text":""},{"location":"#motivation","title":"Motivation","text":"<p>This library aims to simplify the process of authenticating users with GitHub in Django Admin pages, inspired by libraries like django-admin-sso</p>"},{"location":"#why-another-library","title":"Why another library?","text":"<ul> <li> <p>This library aims for simplicity and ease of use. django-allauth is   de facto solution for Authentication in Django, but add lots of boilerplate, specially the html templates.   Django-GitHub-SSO just add the \"Login with Google\" button in the default login page.</p> Light ModeDark Mode <p></p> <p></p> </li> </ul>"},{"location":"#install","title":"Install","text":"<pre><code>pip install django-github-sso\n</code></pre> <p>Currently this project supports:</p> <ul> <li>Python 3.11, 3.12 and 3.13</li> <li>Django 4.2, 5.0, 5.1 and 5.2</li> </ul> <p>Older python/django versions are not supported.</p>"},{"location":"admin/","title":"Using Django Admin","text":"<p>Django GitHub SSO integrates with Django Admin, adding an Inline Model Admin to the User model. This way, you can access the GitHub SSO data for each user.</p>"},{"location":"admin/#using-custom-user-model","title":"Using Custom User model","text":"<p>If you are using a custom user model, you may need to add the <code>GitHubSSOInlineAdmin</code> inline model admin to your custom user model admin, like this:</p> <pre><code># admin.py\n\nfrom django.contrib import admin\nfrom django.contrib.auth.admin import UserAdmin\nfrom django_github_sso.admin import (\n    GitHubSSOInlineAdmin, get_current_user_and_admin\n)\n\nCurrentUserModel, last_admin, LastUserAdmin = get_current_user_and_admin()\n\nif admin.site.is_registered(CurrentUserModel):\n    admin.site.unregister(CurrentUserModel)\n\n\n@admin.register(CurrentUserModel)\nclass CustomUserAdmin(LastUserAdmin):\n    inlines = (\n        tuple(set(list(last_admin.inlines) + [GitHubSSOInlineAdmin]))\n        if last_admin\n        else (GitHubSSOInlineAdmin,)\n    )\n</code></pre> <p>The <code>get_current_user_and_admin</code> helper function will return:</p> <ul> <li>the current registered UserModel in Django Admin (default: <code>django.contrib.auth.models.User</code>)</li> <li>the current registered UserAdmin in Django (default: <code>django.contrib.auth.admin.UserAdmin</code>)</li> <li>the instance of the current registered UserAdmin in Django (default: <code>None</code>)</li> </ul> <p>Use these objects to maintain previous inlines and register your custom user model in Django Admin.</p>"},{"location":"advanced/","title":"Advanced Use","text":""},{"location":"advanced/#using-custom-authentication-backend","title":"Using Custom Authentication Backend","text":"<p>If the users need to log in using a custom authentication backend, you can use the <code>GITHUB_SSO_AUTHENTICATION_BACKEND</code> setting:</p> <pre><code># settings.py\n\nGITHUB_SSO_AUTHENTICATION_BACKEND = \"myapp.authentication.MyCustomAuthenticationBackend\"\n</code></pre>"},{"location":"advanced/#using-github-as-single-source-of-truth","title":"Using GitHub as Single Source of Truth","text":"<p>If you want to use GitHub as the single source of truth for your users, you can simply set the <code>GOOGLE_SSO_ALWAYS_UPDATE_USER_DATA</code>. This will enforce the basic user data (first name, last name, email and picture) to be updated at every login.</p> <pre><code># settings.py\n\nGITHUB_SSO_ALWAYS_UPDATE_USER_DATA = True  # Always update user data on login\n</code></pre> <p>If you need more advanced logic, you can use the <code>GITHUB_SSO_PRE_LOGIN_CALLBACK</code> setting to import custom data from GitHub (considering you have configured the right scopes and possibly a Custom User model to store these fields).</p> <p>For example, you can use the following code to retrieve repository projects:</p> <pre><code># settings.py\n\nGITHUB_SSO_SAVE_ACCESS_TOKEN = True  # You will need this token\nGITHUB_SSO_PRE_LOGIN_CALLBACK = \"hooks.pre_login_user\"\nGITHUB_SSO_SCOPES = [\n    \"read:user\",\n    \"user:email\",\n    \"read:org\",\n    \"read:project\",  # &lt;- additional scope\n]\n</code></pre> <pre><code># myapp/hooks.py\nfrom github import Auth, Github\nfrom loguru import logger\n\n\ndef pre_login_user(user, request):\n    token = request.session.get(\"github_sso_access_token\")\n    if token:\n        # Request GitHub User Info\n        # To retrieve user's additional data, you need to add the respective scope,\n        # For example, \"read:project\" in settings GITHUB_SSO_SCOPES\n        auth = Auth.Token(token)\n        g = Github(auth=auth)\n        github_user = g.get_user()\n        project_info = github_user.get_repos()[0].get_projects()\n        logger.debug(f\"Updating User Data with GitHub Project Info: {project_info}\")\n</code></pre>"},{"location":"callback/","title":"Get your Callback URI","text":"<p>The callback URL is the URL where your GitHub will redirect the user after the authentication process. This URL must be registered in your GitHub OAuth App.</p>"},{"location":"callback/#the-callback-uri","title":"The Callback URI","text":"<p>The callback URI is composed of <code>{scheme}://{netloc}/{path}/</code>, where the netloc is the domain name of your Django project, and the path is <code>/github_sso/callback/</code>. For example, if your Django project is hosted on <code>https://myproject.com</code>, then the callback URL will be <code>https://myproject.com/github_sso/callback/</code>.</p> <p>So, let's break each part of this URI:</p>"},{"location":"callback/#the-scheme","title":"The scheme","text":"<p>The scheme is the protocol used to access the URL. It can be <code>http</code> or <code>https</code>. Django-GitHub-SSO will select the same scheme used by the URL which shows to you the login page.</p> <p>For example, if you're running locally, like <code>http://localhost:8000/accounts/login</code>, then the callback URL scheme will be <code>http://</code>.</p> How about a Reverse-Proxy? <p>If you're running Django behind a reverse-proxy, please make sure you're passing the correct <code>X-Forwarded-Proto</code> header to the login request URL.</p>"},{"location":"callback/#the-netloc","title":"The NetLoc","text":"<p>The NetLoc is the domain of your Django project. It can be a dns name, or an IP address, including the Port, if needed. Some examples are: <code>example.com</code>, <code>localhost:8000</code>, <code>api.my-domain.com</code>, and so on. To find the correct netloc, Django-GitHub-SSO will check, in that order:</p> <ul> <li>If settings contain the variable <code>GITHUB_SSO_CALLBACK_DOMAIN</code>, it will use this value.</li> <li>If Sites Framework is active, it will use the domain field for the current site.</li> <li>The netloc found in the URL which shows you the login page.</li> </ul>"},{"location":"callback/#the-path","title":"The Path","text":"<p>The path is the path to the callback view. It will be always <code>/&lt;path in urls.py&gt;/callback/</code>.</p> <p>Remember when you add this to the <code>urls.py</code>?</p> <pre><code>from django.urls import include, path\n\nurlpatterns = [\n    # other urlpatterns...\n    path(\n        \"github_sso/\", include(\n            \"django_github_sso.urls\",\n            namespace=\"django_github_sso\"\n        )\n    ),\n]\n</code></pre> <p>The path starts with the <code>github_sso/</code> part. If you change this to <code>sso/</code> for example, your callback URL will change to <code>https://myproject.com/sso/callback/</code>.</p>"},{"location":"callback/#registering-the-uri","title":"Registering the URI","text":"<p>If you need to change your callback URL, navigate back to <code>https://github.com/organizations/&lt;YOUR ORGANIZATION&gt;/settings/applications</code>, change the field <code>Authorization callback URL</code> and click <code>Update Application</code>.</p> <p></p> <p>Do not forget the trailing slash</p> <p>Many errors on this step are caused by forgetting the trailing slash:</p> <ul> <li>Good: <code>http://localhost:8000/github_sso/callback/</code></li> <li>Bad: <code>http://localhost:8000/github_sso/callback</code></li> </ul> <p>In the next step, we will configure Django-GitHub-SSO to auto create the Users.</p>"},{"location":"customize/","title":"Customizing the Login Page","text":"<p>Below, you can find some tips on how to customize the login page.</p>"},{"location":"customize/#hiding-the-login-form","title":"Hiding the Login Form","text":"<p>If you want to show only the GitHub Login button, you can hide the login form using the <code>SSO_SHOW_FORM_ON_ADMIN_PAGE</code> setting.</p> <pre><code># settings.py\n\nSSO_SHOW_FORM_ON_ADMIN_PAGE = False\n</code></pre>"},{"location":"customize/#customizing-the-login-button","title":"Customizing the Login button","text":"<p>Customizing the Login button is very simple. For the logo and text change is straightforward, just inform the new values. For the style, you can override the css file.</p>"},{"location":"customize/#the-button-logo","title":"The button logo","text":"<p>To change the logo, use the <code>GITHUB_SSO_BUTTON_LOGO</code> setting.</p> <pre><code># settings.py\nGITHUB_SSO_LOGO_URL = \"https://example.com/logo.png\"\n</code></pre>"},{"location":"customize/#the-button-text","title":"The button text","text":"<p>To change the text, use the <code>GITHUB_SSO_BUTTON_TEXT</code> setting.</p> <pre><code># settings.py\n\nGITHUB_SSO_TEXT = \"New login message\"\n</code></pre>"},{"location":"customize/#the-button-style","title":"The button style","text":"<p>The login button css style is located at <code>static/django_github_sso/github_button.css</code>. You can override this file as per Django static files documentation.</p>"},{"location":"customize/#an-example","title":"An example","text":"<pre><code># settings.py\n\nGITHUB_SSO_TEXT = \"Login using GitHub Org\"\n</code></pre> <pre><code>/* static/django_github_sso/github_button.css */\n\n/* other css... */\n\n.github-login-btn {\n    background-color: #40758f;\n    border: 1px solid #40758f;\n    padding: 1px;\n    margin-bottom: 10px;\n    width: 100%;\n    height: 28px;\n    display: flex;\n}\n</code></pre> <p>The result:</p> <p></p>"},{"location":"how/","title":"How Django GitHub SSO works?","text":""},{"location":"how/#current-flow","title":"Current Flow","text":"<ol> <li> <p>First, the user is redirected to the Django login page. If settings <code>GITHUB_SSO_ENABLED</code> is True, the \"Login with GitHub\" button will be added to a default form.</p> </li> <li> <p>On click, Django-GitHub-SSO will add, in a anonymous request session, the <code>sso_next_url</code> and GitHub Auth info. This data will expire in 10 minutes. Then user will be redirected to GitHub login page.</p> <p>Using Request Anonymous session</p> <p>If you make any actions which change or destroy this session, like restart django, clear cookies or change browsers, ou move between <code>localhost</code> and <code>127.0.0.1</code>, the login will fail, and you can see the message \"State Mismatched. Time expired?\" in the next time you log in again. Also remember the anonymous session lasts for 10 minutes, defined in<code>GITHUB_SSO_TIMEOUT</code>.</p> </li> <li> <p>On callback, Django-GitHub-SSO will check <code>code</code> and <code>state</code> received. If they are valid, GitHub's UserInfo will be retrieved. If the user is already registered in Django, the user will be logged in.</p> </li> <li> <p>Otherwise, the user will be created and logged in, if his email domain, matches one of the <code>GITHUB_SSO_ALLOWABLE_DOMAINS</code>. You can disable the auto-creation setting <code>GITHUB_SSO_AUTO_CREATE_USERS</code> to False.</p> </li> <li> <p>On creation only, this user can be set to the<code>staff</code> or <code>superuser</code> status, if his email are in <code>GITHUB_SSO_STAFF_LIST</code> or <code>GITHUB_SSO_SUPERUSER_LIST</code> respectively. Please note if you add an email to one of these lists, the email domain must be added to <code>GITHUB_SSO_ALLOWABLE_DOMAINS</code>too.</p> </li> <li> <p>This authenticated session will expire in 1 hour, or the time defined, in seconds, in <code>GITHUB_SSO_SESSION_COOKIE_AGE</code>.</p> </li> <li> <p>If login fails, you will be redirected to route defined in <code>GOOGLE_SSO_LOGIN_FAILED_URL</code> (default: <code>admin:index</code>) which will use Django Messaging system to show the error message.</p> </li> <li> <p>If login succeeds, the user will be redirected to the <code>next_path</code> saved in the anonymous session, or to the route defined in <code>GOOGLE_SSO_NEXT_URL</code> (default: <code>admin:index</code>) as a fallback.</p> </li> </ol>"},{"location":"how/#the-define_sso_providers-template-tag","title":"The <code>define_sso_providers</code> template tag","text":"<p>Django-Microsoft-SSO uses this tag to define which buttons to show on the login page. This is because the same tag is used in other libraries, like django-google-sso and django-github-sso. This tag checks the <code>*_SSO_ENABLED</code>, <code>*_SSO_ADMIN_ENABLED</code> and <code>*_SSO_PAGES_ENABLED</code> settings to return a list of enabled SSO providers for the current request.</p> <p>if you need to customize this, you can pass in the request context the <code>sso_providers</code> variable with a list of providers to show, like this:</p> <pre><code># views.py\nfrom django.shortcuts import render\n\ndef my_view(request):\n    ...\n    sso_providers = [\n        {\n            \"name\": \"Microsoft\",\n            \"logo_url\": \"...\", # URL for the button logo\n            \"text\": \"...\",  # Text for the button\n            \"login_url\": \"...\",  # URL to redirect to start the login flow\n            \"css_url\": \"...\",  # URL for the button CSS\n         }\n    ]\n    return render(request, \"my_login_template.html\", {\"sso_providers\": sso_providers})\n</code></pre> <p>Also, if you're using async views, you can run the original template tags, like this:</p> <pre><code># views.py\nfrom django.shortcuts import render\nfrom django_github_sso.utils import adefine_sso_providers, adefine_show_form\n\nasync def my_async_view(request):\n    ...\n    context = {\n        \"show_admin_form\": await adefine_show_form(request),\n        \"sso_providers\": await adefine_sso_providers(request)\n    }\n    return render(request, \"my_login_template.html\", context)\n</code></pre> <p>The same is valid for define_show_form tag</p> <p>You can pass in the request context the <code>show_admin_form</code> variable with a boolean value to show or hide the default login form.</p>"},{"location":"model/","title":"Getting GitHub info","text":""},{"location":"model/#the-user-model","title":"The User model","text":"<p>Django GitHub SSO saves in the database the following information from GitHub, using current <code>User</code> model:</p> <ul> <li><code>email</code>: The primary verified email address of the user.</li> <li><code>first_name</code>: The first name of the user.</li> <li><code>last_name</code>: The last name of the user.</li> <li><code>username</code>: The primary verified email address of the user</li> <li><code>password</code>: An unusable password, generated using <code>get_unusable_password()</code> from Django.</li> </ul> <p>Getting data on code is straightforward:</p> <pre><code>from django.contrib.auth.decorators import login_required\nfrom django.http import JsonResponse, HttpRequest\n\n@login_required\ndef retrieve_user_data(request: HttpRequest) -&gt; JsonResponse:\n    user = request.user\n    return JsonResponse({\n        \"email\": user.email,\n        \"first_name\": user.first_name,\n        \"last_name\": user.last_name,\n        \"username\": user.username,\n    })\n</code></pre>"},{"location":"model/#the-githubssouser-model","title":"The GitHubSSOUser model","text":"<p>Also, on the <code>GitHubSSOUser</code> model, it saves the following information:</p> <ul> <li><code>github_id</code>: The internal GitHub user ID.</li> <li><code>picture_url</code>: The GitHub user picture URL.</li> <li><code>user_name</code>: The public GitHub user ID.</li> </ul> <p>This is a one-to-one relationship with the <code>User</code> model, so you can access this data using the <code>githubssouser</code> reverse relation attribute:</p> <pre><code>from django.contrib.auth.decorators import login_required\nfrom django.http import JsonResponse, HttpRequest\n\n@login_required\ndef retrieve_user_data(request: HttpRequest) -&gt; JsonResponse:\n    user = request.user\n    return JsonResponse({\n        \"email\": user.email,\n        \"first_name\": user.first_name,\n        \"last_name\": user.last_name,\n        \"username\": user.username,\n        \"github_id\": user.githubssouser.github_id,\n        \"picture_url\": user.githubssouser.picture_url,\n        \"user_name\": user.githubssouser.user_name,\n    })\n</code></pre> <p>You can also import the model directly, like this:</p> <pre><code>from django_github_sso.models import GitHubSSOUser\n\ngithub_info = GitHubSSOUser.objects.get(user=user)\n</code></pre> <p>You can disable this model</p> <p>If you don't want to save this basic data in the database, you can disable the <code>GitHubSSOUser</code> model by setting the <code>GITHUB_SSO_SAVE_BASIC_GITHUB_INFO</code> configuration to <code>False</code> in your <code>settings.py</code> file.</p>"},{"location":"model/#about-github-scopes","title":"About GitHub Scopes","text":"<p>To retrieve this data, Django GitHub SSO uses the following scope from Scopes for OAuth apps:</p> <pre><code>GITHUB_SSO_SCOPES = [  # GitHub default scope\n   \"read:user\", \"user:email\", \"read:org\"\n]\n</code></pre> <p>You can change this scopes overriding the <code>GITHUB_SSO_SCOPES</code> setting in your <code>settings.py</code> file. But if you ask the user to authorize more scopes, this plugin will not save this additional data in the database. You will need to implement your own logic to save this data, calling GitHub again. You can see an example here.</p> <p>The main goal here is simplicity</p> <p>The main goal of this plugin is to be simple to use as possible. But it is important to ask the user once for the scopes. That's why this plugin permits you to change the scopes, but will not save the additional data from it.</p>"},{"location":"model/#the-access-token","title":"The Access Token","text":"<p>To make login possible, Django GitHub SSO needs to get an access token from GitHub. This token is used to retrieve User info to get or create the user in the database. If you need this access token, you can get it inside the User Request Session, like this:</p> <pre><code>from django.contrib.auth.decorators import login_required\nfrom django.http import JsonResponse, HttpRequest\n\n@login_required\ndef retrieve_user_data(request: HttpRequest) -&gt; JsonResponse:\n    user = request.user\n    return JsonResponse({\n        \"email\": user.email,\n        \"first_name\": user.first_name,\n        \"last_name\": user.last_name,\n        \"username\": user.username,\n        \"github_id\": user.githubssouser.github_id,\n        \"picture_url\": user.githubssouser.picture_url,\n        \"user_name\": user.githubssouser.user_name,\n        \"access_token\": request.session[\"github_sso_access_token\"],\n    })\n</code></pre> <p>Saving the Access Token in User Session is disabled, by default, to avoid security issues. If you need to enable it, you can set the configuration <code>GITHUB_SSO_SAVE_ACCESS_TOKEN</code> to <code>True</code> in your <code>settings.py</code> file. Please make sure you understand how to secure your cookies before enabling this option.</p>"},{"location":"multiple/","title":"Using Multiple Social Logins","text":"<p>A special advanced case is when you need to log in from multiple social providers. In this case, each provider will have its own package which you need to install and configure. Currently, we support:</p> <ul> <li>Django Google SSO</li> <li>Django Microsoft SSO</li> <li>Django GitHub SSO</li> </ul>"},{"location":"multiple/#install-the-packages","title":"Install the Packages","text":"<p>Install the packages you need:</p> <pre><code>pip install django-google-sso django-microsoft-sso django-github-sso\n\n# Optionally install Stela to handle .env files\npip install stela\n</code></pre>"},{"location":"multiple/#add-package-to-django-project","title":"Add Package to Django Project","text":"<p>To add this package in your Django Project, please modify the <code>INSTALLED_APPS</code> in your <code>settings.py</code>:</p> <pre><code># settings.py\n\nINSTALLED_APPS = [\n    # other django apps\n    \"django.contrib.messages\",  # Need for Auth messages\n    \"django_github_sso\",  # Will show as first button in login page\n    \"django_google_sso\",\n    \"django_microsoft_sso\",\n]\n</code></pre> <p>Order matters</p> <p>The first package on list will be the first button in the login page.</p>"},{"location":"multiple/#add-secrets-to-env-file","title":"Add secrets to env file","text":"<pre><code># .env.local\nGOOGLE_SSO_CLIENT_ID=999999999999-xxxxxxxxx.apps.googleusercontent.com\nGOOGLE_SSO_CLIENT_SECRET=xxxxxx\nGOOGLE_SSO_PROJECT_ID=999999999999\n\nMICROSOFT_SSO_APPLICATION_ID=FOO\nMICROSOFT_SSO_CLIENT_SECRET=BAZ\n\nGITHUB_SSO_CLIENT_ID=BAR\nGITHUB_SSO_CLIENT_SECRET=FOOBAR\n</code></pre>"},{"location":"multiple/#setup-django-urls","title":"Setup Django URLs","text":"<p>Add the URLs of each provider to your <code>urls.py</code> file:</p> <pre><code>from django.urls import include, path\n\n\nurlpatterns += [\n    path(\n        \"github_sso/\",\n        include(\"django_google_sso.urls\", namespace=\"django_github_sso\"),\n    ),\n    path(\n        \"google_sso/\",\n        include(\"django_github_sso.urls\", namespace=\"django_google_sso\"),\n    ),\n        path(\n        \"microsoft_sso/\",\n        include(\"django_microsoft_sso.urls\", namespace=\"django_microsoft_sso\"),\n    ),\n]\n</code></pre>"},{"location":"multiple/#setup-django-settings","title":"Setup Django Settings","text":"<p>Add the settings of each provider to your <code>settings.py</code> file:</p> <pre><code># settings.py\nfrom stela import env\n\n# Django Microsoft SSO\nMICROSOFT_SSO_ENABLED = True\nMICROSOFT_SSO_APPLICATION_ID = env.MICROSOFT_SSO_APPLICATION_ID\nMICROSOFT_SSO_CLIENT_SECRET = env.MICROSOFT_SSO_CLIENT_SECRET\nMICROSOFT_SSO_ALLOWABLE_DOMAINS = [\"contoso.com\"]\n\n# Django Google SSO\nGOOGLE_SSO_ENABLED = True\nGOOGLE_SSO_CLIENT_ID = env.GOOGLE_SSO_CLIENT_ID\nGOOGLE_SSO_PROJECT_ID = env.GOOGLE_SSO_PROJECT_ID\nGOOGLE_SSO_CLIENT_SECRET = env.GOOGLE_SSO_CLIENT_SECRET\nGOOGLE_SSO_ALLOWABLE_DOMAINS = [\"contoso.net\"]\n\n# Django GitHub SSO\nGITHUB_SSO_ENABLED = True\nGITHUB_SSO_CLIENT_ID = env.GITHUB_SSO_CLIENT_ID\nGITHUB_SSO_CLIENT_SECRET = env.GITHUB_SSO_CLIENT_SECRET\nGITHUB_SSO_ALLOWABLE_ORGANIZATIONS = [\"contoso\"]\n</code></pre> <p>The login page will look like this:</p> <p></p> <p>You can hide the login form</p> <p>If you want to show only the SSO buttons, you can hide the login form using the <code>SSO_SHOW_FORM_ON_ADMIN_PAGE</code> setting.</p> <pre><code># settings.py\n\nSSO_SHOW_FORM_ON_ADMIN_PAGE = False\n</code></pre>"},{"location":"multiple/#avoiding-duplicated-users","title":"Avoiding duplicated Users","text":"<p>Both Django GitHub SSO and Django Microsoft SSO can create users without an email address, comparing the User <code>username</code> field against the Azure User Principal Name or Github User Name. This can cause duplicated users if you are using either package.</p> <p>To avoid this, you can set the <code>MICROSOFT_SSO_UNIQUE_EMAIL</code> and <code>GITHUB_SSO_UNIQUE_EMAIL</code> settings to <code>True</code>, making these packages compare User <code>email</code> against Azure Mail field or Github Primary Email. Make sure your Azure Tenant and GitHub Organization users have registered emails.</p>"},{"location":"multiple/#the-django-e003w003-warning","title":"The Django E003/W003 Warning","text":"<p>If you are using multiple Django SSO projects, you will get a warning like this:</p> <pre><code>WARNINGS:\n?: (templates.E003) 'show_form' is used for multiple template tag modules: 'django_google_sso.templatetags.show_form', 'django_microsoft_sso.templatetags.show_form'\n?: (templates.E003) 'sso_tags' is used for multiple template tag modules: 'django_google_sso.templatetags.sso_tags', 'django_microsoft_sso.templatetags.sso_tags'\n</code></pre> <p>This is because both packages use the same template tags. To silence this warning, you can set the <code>SILENCED_SYSTEM_CHECKS</code> as per Django documentation:</p> <pre><code># settings.py\nSILENCED_SYSTEM_CHECKS = [\"templates.W003\"]  # Or \"templates.E003\" for Django &lt;=5.0\n</code></pre> <p>But if you need to check the templates, you can use the <code>SSO_USE_ALTERNATE_W003</code> setting to use an alternate template tag. This alternate check will run the original check, but will not raise the warning for the Django SSO packages. To use this alternate check, you need to set both the Django Silence Check and <code>SSO_USE_ALTERNATE_W003</code>:</p> <pre><code># settings.py\n\nSILENCED_SYSTEM_CHECKS = [\"templates.W003\"]  # Will silence the original check\nSSO_USE_ALTERNATE_W003 = True  # Will run alternate check\n</code></pre> <p>The tags will be executed only once, per request, for the last installed package</p> <p>To avoid multiple executions for the <code>define_sso_providers</code> and <code>define_show_form</code> tags, these code will be executed once and the result will be cached on the request object. Due to django template loading mechanism, the tag's code from the last installed package will be the one executed. This means if you have multiple packages installed, only the last one will be executed. To avoid this, you can use the <code>sso_providers</code> and <code>show_admin_form</code> context variables to pass the values you want to show in the template.</p> <pre><code># views.py\nfrom django.shortcuts import render\nfrom django_github_sso.template_tags import define_sso_providers, define_show_form\n\ndef my_login_view(request):\n    ...\n    sso_providers = define_sso_providers({\"context\": request})\n    show_admin_form = define_show_form({\"context\": request})\n\n    return render(\n        request,\n        \"my_login_template.html\",\n        {\"sso_providers\": sso_providers, \"show_admin_form\": show_admin_form},\n    )\n</code></pre>"},{"location":"multiple/#split-providers-between-admin-and-page-logins","title":"Split Providers between Admin and Page Logins","text":"<p>If you want to use different providers for Admin and Page logins, you may need to enable/disable providers per request. For example, suppose if you want to use both Django Google SSO, Django GitHub SSO and Django Microsoft SSO for Page login but only  Django GitHub SSO for the Admin, you can add the respective <code>*_SSO_PAGES_ENABLED</code> and <code>*_SSO_ADMIN_ENABLED</code>, like this:</p> <pre><code># settings.py\n# Control globally - both Admin and Pages (default: True)\nMICROSOFT_SSO_ENABLED = True\nGOOGLE_SSO_ENABLED = True\nGITHUB_SSO_ENABLED = True\n\n# Use Google and Microsoft SSO for Pages only\n# Always define both Admin and Pages settings\nGOOGLE_SSO_ADMIN_ENABLED = False\nGOOGLE_SSO_PAGES_ENABLED = True\nMICROSOFT_SSO_ADMIN_ENABLED = False\nMICROSOFT_SSO_PAGES_ENABLED = True\n\n# Explicitly configure Google and Microsoft Settings\n# to make sure they cannot have Admin privileges\nGOOGLE_SSO_ALLOWABLE_DOMAINS = [\"*\"]\nGOOGLE_SSO_AUTO_CREATE_FIRST_SUPERUSER = False\nGOOGLE_SSO_STAFF_LIST = []\nGOOGLE_SSO_SUPERUSER_LIST = []\nGOOGLE_SSO_FAILED_LOGIN_URL = \"index\"\nGOOGLE_SSO_NEXT_URL = \"secret\"\nMICROSOFT_SSO_ALLOWABLE_DOMAINS = [\"*\"]\nMICROSOFT_SSO_AUTO_CREATE_FIRST_SUPERUSER = False\nMICROSOFT_SSO_STAFF_LIST = []\nMICROSOFT_SSO_SUPERUSER_LIST = []\nMICROSOFT_SSO_FAILED_LOGIN_URL = \"index\"\nMICROSOFT_SSO_NEXT_URL = \"secret\"\n</code></pre> <p>You need to be explicit on these settings</p> <p>If you set <code>GITHUB_SSO_ADMIN_ENABLED = False</code> and do not set <code>GITHUB_SSO_PAGES_ENABLED</code>, the default value for <code>GITHUB_SSO_PAGES_ENABLED</code> is also <code>False</code>. This means Microsoft SSO will be disabled for both Admin and Page logins. You need to be explicit on these settings.</p>"},{"location":"pages/","title":"Using Django GitHub SSO outside Django Admin","text":"<p>Django GitHub SSO aims for simplicity, that's why the primary focus is on the Admin login logic. But this package can be used outside Django Admin, in a custom login page. To do so, you can follow the steps below.</p> <p>This is the Tip of the Iceberg</p> <p>In real-life projects, user customer login involves more than just a login button. You need to implement many features like OTP, Captcha, \"Recover Password\", \"Remember Me\", \"Login with Passkey\" etc. This documentation shows a simple implementation to demonstrate how to use Django GitHub SSO outside Django Admin, but for more complex UX requisites, please check full solutions like django-allauth, or incremental solutions like django-otp, django-recaptcha, django-passkeys, etc.</p>"},{"location":"pages/#add-django-github-sso-templates-to-your-login-page","title":"Add Django GitHub SSO templates to your login page","text":"<p>Inside your login template, just add these two lines:</p> <ul> <li><code>{% include 'github_sso/login_sso.html' %}</code> inside <code>&lt;body&gt;</code></li> <li><code>{% static 'django_github_sso/github_button.css' %}</code> inside <code>&lt;head&gt;</code></li> </ul>"},{"location":"pages/#login-template-example","title":"Login template example","text":"<pre><code>{% load static %}\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n    &lt;head&gt;\n        &lt;meta charset=\"UTF-8\"&gt;\n        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n        &lt;title&gt;Page Login&lt;/title&gt;\n        &lt;link rel=\"stylesheet\" href=\"{% static 'django_google_sso/google_button.css' %}\"&gt;\n        &lt;link rel=\"stylesheet\" href=\"{% static 'django_microsoft_sso/microsoft_button.css' %}\"&gt;\n        &lt;link rel=\"stylesheet\" href=\"{% static 'django_github_sso/github_button.css' %}\"&gt;\n        &lt;link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/css/bootstrap.min.css\" rel=\"stylesheet\"\n              integrity=\"sha384-SgOJa3DmI69IUzQ2PVdRZhwQ+dy64/BUtbMJw1MZ8t5HZApcHrRKUc4W0kG879m7\" crossorigin=\"anonymous\"&gt;\n        &lt;style&gt;\n            body {\n                background-color: #f8f9fa;\n            }\n            .microsoft-login-btn, .google-login-btn, .github-login-btn {\n                padding: 6px 4px;\n                height: 36px;\n            }\n        &lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body class=\"container d-flex flex-column vh-100\"&gt;\n        &lt;div class=\"d-flex flex-column w-100\"&gt;\n            {% if messages %}\n                {% for message in messages %}\n                    &lt;div class=\"alert\n                                {% if message.tags == 'error' %}alert-danger{% else %}alert-{{ message.tags }}{% endif %}\" role=\"alert\"&gt;\n                        {{ message }}\n                    &lt;/div&gt;\n                {% endfor %}\n            {% endif %}\n        &lt;/div&gt;\n        &lt;div class=\"d-flex flex-column justify-content-center align-items-center flex-grow-1\"&gt;\n            &lt;div class=\"card p-4 d-flex align-items-center\" style=\"width: 22rem;\"&gt;\n                &lt;div class=\"h4\"&gt;Django GitHub SSO&lt;/div&gt;\n                {% include 'github_sso/login_sso.html' %}\n                &lt;a href=\"{% url 'admin:index' %}\" class=\"mt-2\"&gt;Go to Admin&lt;/a&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>The <code>include</code> command will add the login button to your template for all django-sso installed in the project.</p>"},{"location":"pages/#define-per-request-parameters","title":"Define per-request parameters","text":"<p>In the case you need different behavior for the login to Admin and login to Django pages, you can define this using callables on the Django GitHub SSO settings. For example:</p> Setting Login to Admin Login to Pages <code>GITHUB_SSO_ALLOWABLE_DOMAINS</code> <code>[\"example.com\"]</code> <code>[\"*\"]</code> <code>GITHUB_SSO_LOGIN_FAILED_URL</code> <code>\"admin:login\"</code> <code>\"index\"</code> <code>GITHUB_SSO_NEXT_URL</code> <code>\"admin:index\"</code> <code>\"secret\"</code> <code>GITHUB_SSO_SESSION_COOKIE_AGE</code> <code>3600</code> <code>86400</code> <code>GITHUB_SSO_STAFF_LIST</code> <code>[...]</code> <code>[]</code> <code>GITHUB_SSO_SUPERUSER_LIST</code> <code>[...]</code> <code>[]</code> <p>You can config almost all settings per request</p> <p>You can config different GitHub credentials, Scopes, Default Locale, etc. Please check the Settings and Sites docs for more details.</p>"},{"location":"pages/#settings-logic-example","title":"Settings logic example","text":"<pre><code># settings.py\nfrom django_github_sso.helpers import is_admin_path\n\n\ndef get_sso_config(request):\n    config = {\n        \"admin\": {\n            \"allowable_domains\": env.get_or_default(\"GITHUB_SSO_ALLOWABLE_DOMAINS\", []),\n            \"allowable_orgs\": env.get_or_default(\"GITHUB_SSO_ALLOWABLE_ORGS\", []),\n            \"needed_repos\": env.get_or_default(\"GITHUB_SSO_NEEDED_REPOS\", []),\n            \"allow_all_users\": env.get_or_default(\"GITHUB_SSO_ALLOW_ALL_USERS\", False),\n            \"login_failed_url\": \"admin:login\",\n            \"next_url\": \"admin:index\",\n            \"session_cookie_age\": 3600,  # 1 hour - default\n            \"staff_list\": env.get_or_default(\"MICROSOFT_SSO_STAFF_LIST\", []),\n            \"superuser_list\": env.get_or_default(\"MICROSOFT_SSO_SUPERUSER_LIST\", []),\n            \"auto_create_first_superuser\": True,  # Create superuser on first eligible user login\n        },\n        \"pages\": {\n            \"allowable_domains\": [\"*\"],\n            \"allowable_orgs\": [],\n            \"needed_repos\": [],\n            \"allow_all_users\": True,\n            \"login_failed_url\": \"index\",\n            \"next_url\": \"secret\",\n            \"session_cookie_age\": 86400,  # 24 hours\n            \"staff_list\": [],\n            \"superuser_list\": [],\n            \"auto_create_first_superuser\": False,\n        },\n    }\n    if is_admin_path(request):\n        logger.debug(\"Returning Admin SSO configuration\")\n        return config[\"admin\"]\n    else:\n        logger.debug(\"Returning Pages SSO configuration\")\n        return config[\"pages\"]\n\n\nGITHUB_SSO_ALLOWABLE_DOMAINS = lambda request: get_sso_config(request)[\"allowable_domains\"]\nGITHUB_SSO_ALLOWABLE_ORGS = lambda request: get_sso_config(request)[\"allowable_orgs\"]\nGITHUB_SSO_NEEDED_REPOS = lambda request: get_sso_config(request)[\"needed_repos\"]\nGITHUB_SSO_ALLOW_ALL_USERS = lambda request: get_sso_config(request)[\"allow_all_users\"]\nGITHUB_SSO_AUTO_CREATE_FIRST_SUPERUSER = lambda request: get_sso_config(request)[\n    \"auto_create_first_superuser\"\n]\nGITHUB_SSO_NEXT_URL = lambda request: get_sso_config(request)[\"next_url\"]\nGITHUB_SSO_LOGIN_FAILED_URL = lambda request: get_sso_config(request)[\"login_failed_url\"]\nGITHUB_SSO_SESSION_COOKIE_AGE = lambda request: get_sso_config(request)[\n    \"session_cookie_age\"\n]\nGITHUB_SSO_STAFF_LIST = lambda request: get_sso_config(request)[\"staff_list\"]\nGITHUB_SSO_SUPERUSER_LIST = lambda request: get_sso_config(request)[\"superuser_list\"]\n</code></pre>"},{"location":"pages/#toggle-github-sso-between-admin-and-page-logins","title":"Toggle GitHub SSO between Admin and Page logins","text":"<p>Finally, if you want to toggle between Admin and Page login, you can enable/disable GitHub SSO using the <code>GITHUB_SSO_PAGES_ENABLED</code> and <code>GITHUB_SSO_ADMIN_ENABLED</code>. For example, if you want to enable GitHub SSO only for Page login:</p> <pre><code># settings.py\n\n# Enable or disable globally\nGITHUB_SSO_ENABLED = True\n\n# Enable or Disable per request\nGITHUB_SSO_ADMIN_ENABLED = False\nGITHUB_SSO_PAGES_ENABLED = True\n</code></pre> <p>How Package knows if the request is for Admin or Page login?</p> <p>The package uses the <code>is_admin_path</code> and <code>is_page_path</code> helpers to check if the <code>request.path</code> starts with the admin path. To find the admin path, the package uses the <code>SSO_ADMIN_ROUTE</code> setting (default: <code>admin:index</code>).</p> <pre><code># settings.py\nfrom django_github_sso.helpers import is_admin_path, is_page_path\n\nSSO_ADMIN_ROUTE = \"admin:index\"  # Default admin route\n\nGITHUB_SSO_ENABLED = True\nGITHUB_SSO_ADMIN_ENABLED = is_admin_path  # Same as True\nGITHUB_SSO_PAGES_ENABLED = is_page_path  # Same as True\n</code></pre>"},{"location":"quick_setup/","title":"Quick Setup","text":""},{"location":"quick_setup/#setup-django-settings","title":"Setup Django Settings","text":"<p>To add this package in your Django Project, please modify the <code>INSTALLED_APPS</code> in your <code>settings.py</code>:</p> <pre><code># settings.py\n\nINSTALLED_APPS = [\n    # other django apps\n    \"django.contrib.messages\",  # Need for Auth messages\n    \"django_github_sso\",  # Add django_github_sso\n]\n</code></pre>"},{"location":"quick_setup/#setup-github-oauth-app","title":"Setup GitHub OAuth App","text":"<p>Navigate to <code>https://github.com/organizations/&lt;YOUR ORGANIZATION&gt;/settings/applications</code>, then select or create a new <code>Org OAuth App</code>. In this tutorial we will create a new App.</p> <p>In the field Authorization callback URI add the address: <code>https://your-domain.com/github_sso/callback/</code> replacing <code>your-domain.com</code> with your real domain (and Port). For example, if you're running locally, you can use <code>http://localhost:8000/github_sso/callback/</code>.</p> <p>Do not forget the trailing slash!</p> <p></p> <p>With this, you can retrieve your <code>Client ID</code>. For the <code>Client Secret</code> please generate a new secret clicking on button <code>Generate a new client secret</code>:</p> <p></p>"},{"location":"quick_setup/#configuring-your-django-project","title":"Configuring your Django Project","text":"<p>After that, add the credentials in your <code>settings.py</code> file:</p> <pre><code># settings.py\nGITHUB_SSO_CLIENT_ID = \"your Application (client) Id here\"\nGITHUB_SSO_CLIENT_SECRET = \"your client secret value here\"\n</code></pre> <p>Don't commit this info in your repository. This permits you to have different credentials for each environment and mitigates security breaches. That's why we recommend you to use environment variables to store this info. To read this data, we recommend you to install and use a Twelve-factor compatible library in your project.</p> <p>For example, you can use our project Stela to load the environment variables from a <code>.env.local</code> file, like this:</p> <pre><code># .env.local\nGITHUB_SSO_CLIENT_ID=\"your Application (client) Id here\"\nGITHUB_SSO_CLIENT_SECRET=\"your client secret value here\"\n</code></pre> <pre><code># Django settings.py\nfrom stela import env\n\nGITHUB_SSO_CLIENT_ID = env.GITHUB_SSO_CLIENT_ID\nGITHUB_SSO_CLIENT_SECRET = env.GITHUB_SSO_CLIENT_SECRET\n</code></pre> <p>But in fact, you can use any library you want, like django-environ, django-constance, python-dotenv, etc...</p>"},{"location":"quick_setup/#setup-auto-create-users","title":"Setup Auto-Create Users","text":"<p>The next option is to set up the auto-create users from Django GitHub SSO. At least one of the following filters must be set:</p> <ul> <li><code>GITHUB_SSO_ALLOWABLE_DOMAINS</code>: will check against user's primary email</li> <li><code>GITHUB_SSO_ALLOWABLE_ORGS</code>: user needs to be a member of all orgs listed</li> <li><code>GITHUB_SSO_NEEDED_REPOS</code>: user needs to be a member of all repos listed</li> </ul> <p>Any combination of these filters can be used.</p> <pre><code># settings.py\n\nGITHUB_SSO_ALLOWABLE_DOMAINS = [\"example.com\"]  # will check against user's primary email\nGITHUB_SSO_ALLOWABLE_ORGS = [\"example\"]  # user needs to be a member of all orgs listed\nGITHUB_SSO_NEEDED_REPOS = [\"example/example-repo\"]  # user needs to be a member of all repos listed\n</code></pre> <p>If the GitHub user is invalid, the user will be redirected to the login page.</p> How can I  allow any GitHub user in my Django Admin? <p>To do this, use the option <code>GITHUB_SSO_ALLOW_ALL_USERS = True</code> in your <code>settings.py</code>. Please make sure you understand the security implications of this option.</p>"},{"location":"quick_setup/#setup-django-urls","title":"Setup Django URLs","text":"<p>And in your <code>urls.py</code> please add the Django-GitHub-SSO views:</p> <pre><code># urls.py\n\nfrom django.urls import include, path\n\nurlpatterns = [\n    # other urlpatterns...\n    path(\n        \"github_sso/\", include(\n            \"django_github_sso.urls\",\n            namespace=\"django_github_sso\"\n        )\n    ),\n]\n</code></pre>"},{"location":"quick_setup/#run-django-migrations","title":"Run Django migrations","text":"<p>Finally, run migrations</p> <pre><code>$ python manage.py migrate\n</code></pre> <p>And, that's it: Django GitHub SSO is ready for use. When you open the admin page, you will see the \"Login with GitHub\" button:</p> Light ModeDark Mode <p></p> <p></p> How about Django Admin skins, like Grappelli? <p>Django GitHub SSO will works with any Django Admin skin which calls the original Django login template, like Grappelli, Django Jazzmin, Django Admin Interface and Django Jet Reboot.</p> <p>If the skin uses his own login template, you will need create your own <code>admin/login.html</code> template to add both HTML from custom login.html from the custom package and from this library.</p> <p>For the next pages, let's see each one of these steps with more details.</p>"},{"location":"settings/","title":"All Django Settings options","text":"Setting Description <code>GITHUB_SSO_ACCEPT_OUTSIDE_COLLABORATORS</code> Accept outside collaborators. Default: <code>False</code> <code>GITHUB_SSO_ADMIN_ENABLED</code> Enable SSO only when allowed on Admin pages. Default: <code>None</code> <code>GITHUB_SSO_ALLOW_ALL_USERS</code> Explicity allow all users. Default: <code>False</code> <code>GITHUB_SSO_ALLOWABLE_DOMAINS</code> List of domains that will be allowed to create users. Default: <code>[]</code> <code>GITHUB_SSO_ALLOWABLE_ORGS</code> List of organizations that will be allowed to create users. Default: <code>[]</code> <code>GITHUB_SSO_ALWAYS_UPDATE_USER_DATA</code> If true, update default user info from GitHub data at every login. This will also make their password unusable. Otherwise, all of this happens only on create. Default: <code>False</code> <code>GITHUB_SSO_AUTHENTICATION_BACKEND</code> The authentication backend to use.  Default: <code>None</code> <code>GITHUB_SSO_AUTO_CREATE_FIRST_SUPERUSER</code> If True, the first user that logs in will be created as superuser if no superuser exists in the database at all. Default: <code>False</code> <code>GITHUB_SSO_AUTO_CREATE_USERS</code> Enable or disable the auto-create users feature. Default: <code>True</code> <code>GITHUB_SSO_CALLBACK_DOMAIN</code> The netloc to be used on Callback URI. Default: <code>None</code> <code>GITHUB_SSO_CHECK_ONLY_PRIMARY_EMAIL</code> Check only primary email. Default: <code>False</code> <code>GITHUB_SSO_CLIENT_ID</code> The GitHub OAuth 2.0 Web Application Client ID. Default: <code>None</code> <code>GITHUB_SSO_CLIENT_SECRET</code> The GitHub OAuth 2.0 Web Application Client Secret. Default: <code>None</code> <code>GITHUB_SSO_ENABLE_LOGS</code> Enable or disable logging for the plugin. Default: <code>True</code> <code>GITHUB_SSO_ENABLE_MESSAGES</code> Show Messages using Django Messages Framework. Default: <code>True</code> <code>GITHUB_SSO_ENABLED</code> Enable or disable the plugin. Default: <code>True</code> <code>GITHUB_SSO_LOGIN_FAILED_URL</code> The named url path that the user will be redirected to if an authentication error is encountered. Default: <code>admin:index</code> <code>GITHUB_SSO_LOGO_URL</code> The URL of the logo to be used on the login button. Default: <code>https://github.githubassets.com/assets/GitHub-Mark-ea2971cee799.png</code> <code>GITHUB_SSO_NEEDED_REPOS</code> List of repositories the user needs to be member to authorize login. Default: <code>[]</code> <code>GITHUB_SSO_NEXT_URL</code> The named url path that the user will be redirected if there is no next url after successful authentication. Default: <code>admin:index</code> <code>GITHUB_SSO_PAGES_ENABLED</code> Enable SSO button injection on non-admin pages. Default: <code>None</code> <code>GITHUB_SSO_PRE_CREATE_CALLBACK</code> Callable for processing pre-create logic. Default: <code>django_github_sso.hooks.pre_create_user</code> <code>GITHUB_SSO_PRE_LOGIN_CALLBACK</code> Callable for processing pre-login logic. Default: <code>django_github_sso.hooks.pre_login_user</code> <code>GITHUB_SSO_PRE_VALIDATE_CALLBACK</code> Callable for processing pre-validate logic. Default: <code>django_github_sso.hooks.pre_validate_user</code> <code>GITHUB_SSO_SAVE_ACCESS_TOKEN</code> Save the access token in the session. Default: <code>False</code> <code>GITHUB_SSO_SAVE_BASIC_GITHUB_INFO</code> Save basic GitHub info in the database. Default: <code>True</code> <code>GITHUB_SSO_SCOPES</code> The GitHub OAuth 2.0 Scopes. Default: <code>[\"read:user\", \"user:email\", \"read:org\"]</code> <code>GITHUB_SSO_SESSION_COOKIE_AGE</code> The age of the session cookie in seconds. Default: <code>3600</code> <code>GITHUB_SSO_SHOW_ADDITIONAL_ERROR_MESSAGES</code> Show additional error messages in django message system when authentication fails. Default: <code>False</code> <code>GITHUB_SSO_SHOW_FAILED_LOGIN_MESSAGE</code> Show a message on browser when the user creation fails on database. Default: `False <code>GITHUB_SSO_STAFF_LIST</code> List of emails that will be created as staff. Default: <code>[]</code> <code>GITHUB_SSO_SUPERUSER_LIST</code> List of emails that will be created as superuser. Default: <code>[]</code> <code>GITHUB_SSO_TEXT</code> The text to be used on the login button. Default: <code>Sign in with GitHub</code> <code>GITHUB_SSO_TIMEOUT</code> The timeout in seconds for the GitHub SSO authentication returns info, in minutes. Default: <code>10</code> <code>GITHUB_SSO_UNIQUE_EMAIL</code> When get or create a new user, check if the email already exists. Default: <code>False</code> <code>SSO_ADMIN_ROUTE</code> The admin index page route. Default: <code>admin:index</code> <code>SSO_SHOW_FORM_ON_ADMIN_PAGE</code> Show the form on the admin page. Default: <code>True</code> <code>SSO_USE_ALTERNATE_W003</code> Use alternate W003 warning. You need to silence original templates.E003 warning. Default: <code>False</code>"},{"location":"sites/","title":"Using Django Sites Framework","text":"<p>Django GitHub SSO now supports the Django Sites Framework, allowing you to have different SSO configurations for different sites in your Django project.</p>"},{"location":"sites/#how-it-works","title":"How It Works","text":"<p>Most configuration settings in Django GitHub SSO can now accept either a direct value or a callable function that receives the current request and returns the appropriate value for the current site.</p> <p>This means you can dynamically determine configuration values based on the current site being accessed, enabling scenarios like:</p> <ul> <li>Different GitHub OAuth credentials per site</li> <li>Different user creation policies per site</li> <li>Different session timeouts per site</li> <li>And more!</li> </ul>"},{"location":"sites/#setup","title":"Setup","text":"<ol> <li>First, ensure the Django Sites Framework is properly configured in your project:</li> </ol> <pre><code># settings.py\nINSTALLED_APPS = [\n    # ...\n    'django.contrib.sites',\n    'django_github_sso',\n    # ...\n]\n\nSITE_ID = 1  # Default site ID\n</code></pre> <ol> <li> <p>Create your sites in the Django admin or via migrations.</p> </li> <li> <p>Configure Django GitHub SSO settings as callables that return different values based on the current site:</p> </li> </ol> <pre><code># settings.py\nfrom django.contrib.sites.shortcuts import get_current_site\n\ndef get_client_id(request):\n    \"\"\"Return different client ID based on the current site.\"\"\"\n    site = get_current_site(request)\n\n    # Map site domains to client IDs\n    client_ids = {\n        'site.com': 'client-id-for-example-com',\n        'other-site.com': 'client-id-for-other-site',\n    }\n\n    return client_ids.get(site.domain, 'default-client-id')\n\n# Configure settings as callables\nGITHUB_SSO_CLIENT_ID = get_client_id\n</code></pre>"},{"location":"sites/#example-complete-site-specific-configuration","title":"Example: Complete Site-Specific Configuration","text":"<p>Here's a more comprehensive example showing how to configure multiple settings per site:</p> <pre><code># settings.py\nfrom django.contrib.sites.shortcuts import get_current_site\n\ndef get_site_config(request, config_key):\n    \"\"\"Get site-specific configuration.\"\"\"\n    site = get_current_site(request)\n\n    # Define configurations for each site\n    site_configs = {\n        'site.com': {\n            'client_id': 'client-id-for-example-com',\n            'client_secret': 'secret-for-example-com',\n            'project_id': 'project-id-for-example-com',\n            'auto_create_users': True,\n            'session_cookie_age': 3600,  # 1 hour\n            'allowable_domains': ['example.com', 'example.org'],\n        },\n        'other-site.com': {\n            'client_id': 'client-id-for-other-site',\n            'client_secret': 'secret-for-other-site',\n            'project_id': 'project-id-for-other-site',\n            'auto_create_users': False,\n            'session_cookie_age': 86400,  # 24 hours\n            'allowable_domains': ['other-site.com'],\n        }\n    }\n\n    # Get config for current site, or use defaults\n    site_config = site_configs.get(site.domain, {})\n    return site_config.get(config_key, None)\n\n# Configure settings as callables\nGITHUB_SSO_CLIENT_ID = lambda request: get_site_config(request, 'client_id')\nGITHUB_SSO_CLIENT_SECRET = lambda request: get_site_config(request, 'client_secret')\nGITHUB_SSO_PROJECT_ID = lambda request: get_site_config(request, 'project_id')\nGITHUB_SSO_AUTO_CREATE_USERS = lambda request: get_site_config(request, 'auto_create_users')\nGITHUB_SSO_SESSION_COOKIE_AGE = lambda request: get_site_config(request, 'session_cookie_age')\nGITHUB_SSO_ALLOWABLE_DOMAINS = lambda request: get_site_config(request, 'allowable_domains')\n</code></pre> <p>Unsupported Settings for Callables</p> <p>All settings support callable configuration, except the following:</p> <ul> <li><code>GITHUB_SSO_ENABLED</code></li> <li><code>GITHUB_SSO_ENABLE_LOGS</code></li> <li><code>SSO_USE_ALTERNATE_W003</code></li> </ul>"},{"location":"thanks/","title":"Thank you","text":"<p>Thank you for using this project. And for all the appreciation, patience and support.</p> <p>I really hope this project can make your life a little easier.</p> <p>Please feel free to check our other projects:</p> <ul> <li>stela: Easily manage project settings and secrets in any python project.</li> <li>django-google-sso: A Django app to enable Single Sign-On with Google Accounts.</li> <li>django-microsoft-sso: A Django app to enable Single Sign-On with Microsoft 365 Accounts.</li> <li>django-github-sso: A Django app to enable Single Sign-On with GitHub Accounts.</li> </ul>"},{"location":"thanks/#donating","title":"Donating","text":"<p>If you like to finance this project, please consider donating:</p> <p></p>"},{"location":"third_party_admins/","title":"Using Third Party Django Admins","text":"<p>Django has a great ecosystem, and many third-party apps are available to completely replace the default UI for Django Admin. We are trying to make Django GitHub SSO compatible as much as possible with these third-party apps. We can divide these apps broadly into two categories: apps which use the original Django Admin login template and apps with custom login templates.</p> How can I know if the third app has a custom login template? <p>Check if the app code contains the <code>templates/admin/login.html</code> file. If the file exists, the app has a custom login template.</p>"},{"location":"third_party_admins/#apps-with-use-original-django-admin-login-template","title":"Apps with use original Django Admin login template","text":"<p>For these apps, Django GitHub SSO will work out of the box. You don't need to do anything special to make it work.</p> <p>Some examples:</p> <ul> <li>Django Admin Interface</li> <li>Django Grappelli</li> <li>Django Jazzmin</li> <li>Django Jet Reboot</li> </ul>"},{"location":"third_party_admins/#apps-with-custom-login-template","title":"Apps with custom login template","text":"<p>For these apps, you will need to create your own <code>admin/login.html</code> template to add both HTML from the custom login.html from the custom package and from this library, using this basic guideline:</p>"},{"location":"third_party_admins/#create-a-custom-templatesadminloginhtml-template","title":"Create a custom <code>templates/admin/login.html</code> template","text":"<p>Suppose the <code>templates/admin/login.html</code> from the 3<sup>rd</sup> party app is using this structure:</p> <pre><code>{% extends \"third_app/base.html\" %}\n\n{% block my_form %}\n    &lt;form method=\"post\" action=\"{% url 'admin:login' %}\"&gt;\n        {% csrf_token %}\n        {{ form.as_p }}\n        &lt;input type=\"submit\" value=\"Log in\"&gt;\n{% endblock %}\n</code></pre> <p>Please add on your project the <code>templates/admin/login.html</code> template:</p> <pre><code>{% extends \"admin/login.html\" %}\n\n{% block my_form %} {# Use the name of the block from the third-party app #}\n    {{ block.super }} {# this will include the 3rd party app login.html content #}\n    {% include \"github_sso/login_sso.html\" %} {# this will include the GitHub SSO login button #}\n{% endblock %}\n</code></pre> <p>Now, let's add support to the <code>SSO_SHOW_FORM_ON_ADMIN_PAGE</code> option. To do this, update the code to include our <code>show_form</code> tag:</p> <pre><code>{% extends \"admin/login.html\" %}\n{% load show_form %}\n\n{% block my_form %} {# Use the name of the block from the third-party app #}\n    {% define_show_form as show_form %}\n        {% if show_form %}\n            {{ block.super }} {# this will include the 3rd party app login.html content #}\n        {% endif %}\n    {% include \"github_sso/login_sso.html\" %} {# this will include the GitHub SSO login button #}\n{% endblock %}\n</code></pre> <p>This is a basic example.</p> <p>In real cases, you will need to understand how to find the correct elements to hide, and/or how to correct positioning the SSO buttons on the 3<sup>rd</sup> party app layout. Use the real life example from <code>django-unfold</code> described below.</p> <p>Also, make sure you understand how Django works with Template inheritance and How to override templates.</p>"},{"location":"third_party_admins/#current-custom-login-apps-support","title":"Current Custom Login Apps support","text":"<p>To this date, Django GitHub SSO provides support out of the box for these apps with custom login templates:</p> <ul> <li>Django Unfold</li> </ul> <p>For the Django Unfold we use this the code on our login template:</p> <pre><code>{% extends \"admin/login.html\" %}\n{% load static %}\n{% load sso_tags %}\n{% load show_form %}\n{% load i18n %}\n\n{% block extrastyle %}\n    {{ block.super }}\n    {% with sso_providers|default:None as sso_providers %}\n        {% if sso_providers is None %}\n            {% define_sso_providers as sso_providers %}\n        {% endif %}\n        {% for provider in sso_providers %}\n            &lt;link rel=\"stylesheet\" href=\"{{ provider.css_url }}\"&gt;\n        {% endfor %}\n    {% endwith %}\n{% endblock %}\n\n{# Default Django Admin Block #}\n{% block content %}\n    &lt;!--\n        You can pass a custom Show Form to this\n        template using the `show_admin_form` context variable.\n        If not provided, the template will use the default\n        `define_show_form` defined in the sso tags.\n    --&gt;\n    {% with show_admin_form|default:None as show_form %}\n        {% if show_form is None %}\n            {% define_show_form as show_form %}\n        {% endif %}\n        {% if show_form %}\n            {{ block.super }}\n        {% endif %}\n        {% include 'github_sso/login_sso.html' %}\n    {% endwith %}\n{% endblock %}\n\n{# Django Unfold Admin Block #}\n{% block base %}\n    {{ block.super }}  {# Process HTML login elements from Django Unfold #}\n    {% include 'github_sso/login_sso.html' %} {# Add GitHub SSO HTML elements #}\n    &lt;script&gt;\n        {% with show_admin_form|default:None as show_form %}\n            {% if show_form is None %}\n                {% define_show_form as show_form %}\n            {% endif %}\n            {% if show_form %}\n                $(document).ready(function() {\n                    $(\".login-box\").insertAfter(\"#login-form\");\n                });\n            {% else %}\n                $(\"#login-form\").remove();\n                $(document).ready(function() {\n                    $(\".login-box\").insertAfter(\".font-semibold.mb-10\");\n                });\n            {% endif %}\n        {% endwith %}\n    &lt;/script&gt;\n{% endblock %}\n</code></pre> <p>And this is the CSS you can use to customize your login button (you will need to create your custom <code>static/django_github_sso/github_button.css/</code> to work):</p> <pre><code>/*\n\n  Please rename this file to github_button.css to override works.\n  This CSS is compatible with Django Unfold CSS\n\n  login-btn\n  ---------------------------------\n  | --------------                 |\n  | | btn-logo   |    btn-label    |\n  | --------------                 |\n  ----------------------------------\n*/\n\n/* Login Button Area */\n.login-btn-area {\n        display: flex;\n        flex-direction: column;\n        justify-content: center;\n        align-items: center;\n        width: 382px;\n}\n\n/* Goggle Login Button */\n.github-login-btn {\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    background-color: #9233e7;\n    border-radius: 6px;\n    padding: 2px;\n    margin-bottom: 20px;\n    width: 100%;\n    height: 38px;\n    font-family: 'Inter', sans-serif;\n    font-size: 14px;\n    font-weight: 600;\n}\n\n/* GitHub Login Button Hover */\n.github-login-btn:hover {\n    background-color: rgb(33, 33, 33);\n    border: 1px solid rgba(167, 167, 167, 0.56);\n}\n\n/* GitHub Login Button Remove Decoration */\n.github-login-btn a {\n    text-decoration: none;\n}\n\n/* GitHub Login Button Logo Area */\n.github-btn-logo {\n    display: flex;\n    justify-content: center;\n    align-content: center;\n    padding: 4px;\n}\n\n\n/* GitHub Login Button Label Area */\n.github-btn-label {\n    color: #ffffff;\n    margin-top: -1px;\n    width: 100%;\n    text-align: center;\n    padding: 0 10px;\n}\n</code></pre>"},{"location":"troubleshooting/","title":"Troubleshooting Guide","text":""},{"location":"troubleshooting/#common-questions","title":"Common questions:","text":"Admin Message: State Mismatched. Time expired? <p>This error occurs when the user is redirected to the Google login page and then returns to the Django login page but original state are not found or session was expired. Please check if the browser has the anonymous session created by Django.</p> Admin Message: User not allowed to login <p>Please check your filters, some combinations can filter all users. Use the option <code>GITHUB_SSO_SHOW_ADDITIONAL_ERROR_MESSAGES</code> to show additional error messages in django message system when authentication fails.</p> There's too much information on logs and messages from this app. <p>You can disable the logs using the <code>GITHUB_SSO_ENABLE_LOGS</code> setting and the messages using the <code>GITHUB_SSO_ENABLE_MESSAGES</code> setting.</p> System goes looping to admin after login. <p>This is because the user data was received from GitHub, but the user was not created in the database or is not active. To see these errors please check the logs or enable the option <code>GITHUB_SSO_SHOW_FAILED_LOGIN_MESSAGE</code> to see failed login messages on browser. Please, make note these messages can be used on exploit attacks.</p> When I config a custom Authentication Backend using GITHUB_SSO_AUTHENTICATION_BACKEND, the lib stops to login, without errors or logs. <p>This is because the value of <code>GITHUB_SSO_AUTHENTICATION_BACKEND</code> is not a valid authentication backend import path. Please check the value of this setting and make sure it is a valid import path to a Django authentication backend.</p> When using one package for Admin and another for Pages, the user can enter in Admin, even if I configure the Pages SSO to not give any admin rights <p>Please check if the user is not already a staff or superuser in the database, especially if you're using the <code>MICROSOFT_SSO_UNIQUE_EMAIL</code> and <code>GITHUB_SSO_UNIQUE_EMAIL</code> options. If the user is already a staff or superuser, he will be able to enter in Admin, even if the SSO package for Pages does not give him any admin rights.</p> Got a \"KeyError: 'NAME'\" error after set SSO_USE_ALTERNATE_W003 <p>If you get a <code>KeyError: 'NAME'</code> error, please set a <code>NAME</code> in <code>TEMPLATES</code> at <code>settings.py</code>:</p> <pre><code># settings.py\n\nTEMPLATES = [\n    {\n        \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",\n        \"NAME\" : \"default\",  # &lt;-- Add name here\n        \"DIRS\": [BASE_DIR / \"templates\"],\n        \"APP_DIRS\": True,\n        \"OPTIONS\": {\n            \"context_processors\": [\n                \"django.template.context_processors.debug\",\n                \"django.template.context_processors.request\",\n                \"django.contrib.auth.context_processors.auth\",\n                \"django.contrib.messages.context_processors.messages\",\n            ],\n        },\n    },\n]\n</code></pre> Got this error when migrating: 'The model User is already registered with 'core.GitHubSSOUserAdmin' <p>This is because you're already define a custom User model and admin in your project. You need to extended the existing user model unregistering your current User Admin class and add manually the <code>GitHubSSOUserAdmin</code> in your custom class. You can use the <code>get_current_user_and_admin</code> helper as explained here (the recommended action), or alternately, you can add the <code>django-google-sso</code> at the end of your <code>INSTALLED_APPS</code> list.</p>"},{"location":"troubleshooting/#example-app","title":"Example App","text":"<p>To test this library please check the <code>Example App</code> provided here.</p>"},{"location":"troubleshooting/#not-working","title":"Not working?","text":"<p>Don't panic. Get a towel and, please, open an issue.</p>"},{"location":"urls/","title":"Setup Django URLs","text":"<p>The base configuration for Django URLs is the same we have described as before: <pre><code># urls.py\n\nfrom django.urls import include, path\n\nurlpatterns = [\n    # other urlpatterns...\n    path(\n        \"github_sso/\", include(\n            \"django_github_sso.urls\",\n            namespace=\"django_github_sso\"\n        )\n    ),\n]\n</code></pre> You can change the initial Path - <code>github_sso/</code> - to whatever you want - just remember to change it in your GitHub OAuth configuration.</p>"},{"location":"urls/#overriding-the-login-view-or-path","title":"Overriding the Login view or Path","text":"<p>If you need to override the login view, or just the path, please add on the new view/class the Django SSO Admin login template:</p> <pre><code>from django.contrib.auth.views import LoginView\nfrom django.urls import path\n\nurlpatterns = [\n    # other urlpatterns...\n    path(\n        \"accounts/login/\",\n        LoginView.as_view(\n            # The modified form with GitHub button\n            template_name=\"github_sso/login.html\"\n        ),\n    ),\n]\n</code></pre> <p>or you can use a complete custom class:</p> <pre><code>from django.contrib.auth.views import LoginView\n\n\nclass MyLoginView(LoginView):\n    template_name = \"github_sso/login.html\"\n</code></pre>"},{"location":"users/","title":"Auto Creating Users","text":"<p>Django GitHub SSO can automatically create users from GitHub SSO authentication. To enable this feature, you need to setup at least one of the available user filters in your <code>settings.py</code>. Let's review each one of them.</p>"},{"location":"users/#available-filters","title":"Available Filters","text":""},{"location":"users/#allowable-repositories","title":"Allowable Repositories","text":"<p>If you want to allow any GitHub users that are members of a specific repository, you can set the <code>GITHUB_SSO_ALLOWABLE_REPOS</code></p> <pre><code># settings.py\n\nGITHUB_SSO_ALLOWABLE_REPOS = [\"my-company/my-repo\"]\n</code></pre> <p>This is the simpler filter, if the user is a member of the repository, it will be allowed to login.</p> <p>Always use repository's full name</p> <p>Please remember to use the full name of the repository, including the organization name. Example: <code>my-company/my-repo</code></p>"},{"location":"users/#allowable-organizations","title":"Allowable Organizations","text":"<p>If you want to allow any GitHub users that are members of a specific organization, you can set the <code>GITHUB_SSO_ALLOWABLE_ORGS</code></p> <pre><code># settings.py\n\nGITHUB_SSO_ALLOWABLE_ORGS = [\"my-company\"]\n</code></pre> <p>User must be member, not outside collaborator, for each org listed. To allow outside collaborators, you can set the <code>GITHUB_SSO_ALLOW_OUTSIDE_COLLABORATORS</code> setting to <code>True</code>:</p> <pre><code># settings.py\n\nGITHUB_SSO_ALLOWABLE_ORGS = [\"my-company\"]\nGITHUB_SSO_ALLOW_OUTSIDE_COLLABORATORS = True\n</code></pre>"},{"location":"users/#allowable-domains-for-emails","title":"Allowable Domains for Emails","text":"<p>If you want to allow any GitHub users with a specific email domain, you can set the <code>GITHUB_SSO_ALLOWABLE_DOMAINS</code> setting:</p> <pre><code># settings.py\nGITHUB_SSO_ALLOWABLE_DOMAINS = [\"my-company.com\"]\n</code></pre> <p>In this example, any users with a <code>my-company.com</code> primary email will be allowed to login. On GitHub, a user can have multiple emails, but only one of them is the primary email. This is the email that will be used for the filter. If you want to check all user emails with the allowable domains, you can set the <code>GITHUB_SSO_CHECK_ONLY_PRIMARY_EMAIL</code> setting to <code>False</code>:</p> <pre><code># settings.py\n\nGITHUB_SSO_ALLOWABLE_DOMAINS = [\"my-company.com\"]\nGITHUB_SSO_CHECK_ONLY_PRIMARY_EMAIL = False\n</code></pre> <p>Django GitHub SSO will always check only against verified emails from the user.</p> What happens if user has more than one valid email? <p>If the user has more than one valid verified email - for example <code>user@my-company.com</code> and <code>full.name@my-company.com</code>, the first one will be used.</p>"},{"location":"users/#combining-filters","title":"Combining Filters","text":"<p>You can combine the filters to allow only users that match all filters. Some examples:</p> <pre><code># settings.py\n\n# Allow only users that have a verified email with the my-company.com domain\nGITHUB_SSO_ALLOWABLE_DOMAINS = [\"my-company.com\"]\nGITHUB_SSO_CHECK_ONLY_PRIMARY_EMAIL = False\n</code></pre> <pre><code># Allow only users that are members of the my-company organization\n# and have a primary email with the my-company.com domain\n# and are members of the my-repo repository\nGITHUB_SSO_ALLOWABLE_ORGS = [\"my-company\"]\nGITHUB_SSO_ALLOWABLE_DOMAINS = [\"my-company.com\"]\nGITHUB_SSO_ALLOWABLE_REPOS = [\"my-company/my-repo\"]\n</code></pre> <pre><code># Allow only users that are members of the my-company organization\n# but accept any email domain and outside collaborators\nGITHUB_SSO_ALLOWABLE_ORGS = [\"my-company\"]\nGITHUB_SSO_ALLOW_OUTSIDE_COLLABORATORS = True\n</code></pre> <p>Allowing any GitHub user in your Django Admin</p> <ul> <li>You need to set the option <code>GITHUB_SSO_ALLOW_ALL_USERS=True</code> to allow any GitHub user in your Django Admin.</li> <li>If you set any filters, this option will be ignored.</li> <li>Please make sure you understand the security implications of this option.</li> </ul>"},{"location":"users/#disabling-the-auto-create-users","title":"Disabling the auto-create users","text":"<p>You can disable the auto-create users feature by setting the <code>GITHUB_SSO_AUTO_CREATE_USERS</code> setting to <code>False</code>:</p> <pre><code>GITHUB_SSO_AUTO_CREATE_USERS = False\n</code></pre> <p>You can also disable the plugin completely:</p> <pre><code>GITHUB_SSO_ENABLED = False\n</code></pre>"},{"location":"users/#giving-permissions-to-auto-created-users","title":"Giving Permissions to Auto-Created Users","text":"<p>If you are using the auto-create users feature, you can give permissions to the users that are created automatically. To do this, you can set the following options in your <code>settings.py</code>:</p> <pre><code># List of emails or github user_names that will be created as staff\nGITHUB_SSO_STAFF_LIST = [\"my-email@my-company.com\", \"my-user-name\"]\n\n# List of emails or github user_names that will be created as superuser\nGITHUB_SSO_SUPERUSER_LIST = [\"another-email@my-company.com\" \"another-user-name\"]\n\n# If True, the first user that checks in will be created as superuser\n# if no superuser exists in the database at all\nGITHUB_SSO_AUTO_CREATE_FIRST_SUPERUSER = True\n</code></pre> <p>Which Email will be used to save this user on Django?</p> <p>The primary email will be used. If the option <code>GITHUB_SSO_CHECK_ONLY_PRIMARY_EMAIL</code> is <code>False</code> and  <code>GITHUB_SSO_ALLOWABLE_DOMAINS</code> is <code>True</code> the first valid email will be used.</p> <p>For staff user creation only, you can add all users using \"*\" as the value:</p> <pre><code># Use \"*\" to add all users as staff\nGITHUB_SSO_STAFF_LIST = [\"*\"]\n</code></pre>"},{"location":"users/#fine-tuning-validation-before-user-validation","title":"Fine-tuning validation before user validation","text":"<p>If you need to do some custom validation before user is validated, you can set the <code>GITHUB_SSO_PRE_VALIDATE_CALLBACK</code> setting to import a custom function that will be called before the user is created. This function will receive two arguments: the <code>github_user</code> instance from GitHub package and <code>request</code> objects.</p> <pre><code># myapp/hooks.py\ndef pre_validate_user(github_user, request):\n    # Check some info from GitHub user and/or request\n    return True  # The user can be created\n</code></pre> <p>Please note, even if this function returns <code>True</code>, the user can be denied if their email is not valid.</p>"},{"location":"users/#fine-tuning-user-info-before-user-creation","title":"Fine-tuning user info before user creation","text":"<p>If you need to do some processing before user is created, you can set the <code>GITHUB_SSO_PRE_CREATE_CALLBACK</code> setting to import a custom function that will be called before the user is created. This function will receive two arguments: the <code>github_user</code> instance and <code>request</code> objects.</p> <p>You can add custom fields to the user model here</p> <p>The <code>pre_create_callback</code> function can return a dictionary with the fields and values that will be passed to <code>User.objects.create()</code> as the <code>defaults</code> argument. This means you can add custom fields to the user model here or change default values for some fields, like <code>username</code>.</p> <p>If not defined, the field <code>username</code> is always the Github Login name.</p> <p>You can't change the fields: <code>first_name</code>, <code>last_name</code>, <code>email</code> and <code>password</code> using this callback. These fields are always passed to <code>User.objects.create()</code> with the values from Graph API and the password is always unusable.</p> <pre><code>import arrow\n\ndef pre_create_callback(\n    github_user: NamedUser | AuthenticatedUser, request: HttpRequest\n) -&gt; dict | None:\n    \"\"\"\n    Callback function called before user is created.\n\n    params:\n        github_user: GitHub User Instance.\n        request: HttpRequest object.\n\n    return: dict content to be passed\n            to User.objects.create() as `defaults` argument.\n    \"\"\"\n\n    return {\n        \"date_joined\": arrow.utcnow().shift(days=-1).datetime,\n    }\n</code></pre>"},{"location":"users/#fine-tuning-users-before-login","title":"Fine-tuning users before login","text":"<p>If you need to do some processing after user is created or retrieved, but before the user is logged in, you can set the <code>GITHUB_SSO_PRE_LOGIN_CALLBACK</code> setting to import a custom function that will be called before the user is logged in. This function will receive two arguments: the <code>user</code> and <code>request</code> objects.</p> <pre><code># myapp/hooks.py\ndef pre_login_user(user, request):\n    # Do something with the user\n    pass\n\n# settings.py\nGITHUB_SSO_PRE_LOGIN_CALLBACK = \"myapp.hooks.pre_login_user\"\n</code></pre> <p>Please remember this function will be invoked only if a user exists, and if it is active. In other words, if the user is eligible for login.</p> <p>You can add your hooks to customize all steps:</p> <ul> <li><code>GITHUB_SSO_PRE_VALIDATE_CALLBACK</code>: Run before the user is validated.</li> <li><code>GITHUB_SSO_PRE_CREATE_CALLBACK</code>: Run before the user is created.</li> <li><code>GITHUB_SSO_PRE_LOGIN_CALLBACK</code>: Run before the user is logged in.</li> </ul> <p>Be careful with these options</p> <p>The idea here is to make your life easier, especially when testing. But if you are not careful, you can give permissions to users that you don't want, or even worse, you can give permissions to users that you don't know. So, please, be careful with these options.</p> <p>For the last step, we will look at the Django URLs.</p>"}]}