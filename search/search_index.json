{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Intro","text":""},{"location":"#welcome-to-django-github-sso","title":"Welcome to Django GitHub SSO","text":""},{"location":"#motivation","title":"Motivation","text":"<p>This library aims to simplify the process of authenticating users with Microsoft in Django Admin pages, inspired by libraries like django-admin-sso</p>"},{"location":"#why-another-library","title":"Why another library?","text":"<ul> <li> <p>This library aims for simplicity and ease of use. django-allauth is   de facto solution for Authentication in Django, but add lots of boilerplate, specially the html templates.   Django-GitHub-SSO just add the \"Login with Google\" button in the default login page.</p> Light ModeDark Mode <p></p> <p></p> </li> </ul>"},{"location":"#install","title":"Install","text":"<pre><code>pip install django-github-sso\n</code></pre> <p>Currently this project supports:</p> <ul> <li>Python 3.10, 3.11 and 3.12</li> <li>Django 4.1, 4.2 and 5.0</li> </ul>"},{"location":"admin/","title":"Using Django Admin","text":"<p>Django GitHub SSO integrates with Django Admin, adding an Inline Model Admin to the User model. This way, you can access the GitHub SSO data for each user.</p>"},{"location":"admin/#using-custom-user-model","title":"Using Custom User model","text":"<p>If you are using a custom user model, you may need to add the <code>GitHubSSOInlineAdmin</code> inline model admin to your custom user model admin, like this:</p> <pre><code># admin.py\n\nfrom django.contrib import admin\nfrom django.contrib.auth.admin import UserAdmin\nfrom django_github_sso.admin import (\n    GitHubSSOInlineAdmin, get_current_user_and_admin\n)\n\nCurrentUserModel, last_admin, LastUserAdmin = get_current_user_and_admin()\n\nif admin.site.is_registered(CurrentUserModel):\n    admin.site.unregister(CurrentUserModel)\n\n\n@admin.register(CurrentUserModel)\nclass CustomUserAdmin(LastUserAdmin):\n    inlines = (\n        tuple(set(list(last_admin.inlines) + [GitHubSSOInlineAdmin]))\n        if last_admin\n        else (GitHubSSOInlineAdmin,)\n    )\n</code></pre> <p>The <code>get_current_user_and_admin</code> helper function will return:</p> <ul> <li>the current registered UserModel in Django Admin (default: <code>django.contrib.auth.models.User</code>)</li> <li>the current registered UserAdmin in Django (default: <code>django.contrib.auth.admin.UserAdmin</code>)</li> <li>the instance of the current registered UserAdmin in Django (default: <code>None</code>)</li> </ul> <p>Use these objects to maintain previous inlines and register your custom user model in Django Admin.</p>"},{"location":"advanced/","title":"Advanced Use","text":""},{"location":"advanced/#using-custom-authentication-backend","title":"Using Custom Authentication Backend","text":"<p>If the users need to log in using a custom authentication backend, you can use the <code>GITHUB_SSO_AUTHENTICATION_BACKEND</code> setting:</p> <pre><code># settings.py\n\nGITHUB_SSO_AUTHENTICATION_BACKEND = \"myapp.authentication.MyCustomAuthenticationBackend\"\n</code></pre>"},{"location":"advanced/#using-github-as-single-source-of-truth","title":"Using GitHub as Single Source of Truth","text":"<p>If you want to use GitHub as the single source of truth for your users, you can simply set the <code>GOOGLE_SSO_ALWAYS_UPDATE_USER_DATA</code>. This will enforce the basic user data (first name, last name, email and picture) to be updated at every login.</p> <pre><code># settings.py\n\nGITHUB_SSO_ALWAYS_UPDATE_USER_DATA = True  # Always update user data on login\n</code></pre> <p>If you need more advanced logic, you can use the <code>GITHUB_SSO_PRE_LOGIN_CALLBACK</code> setting to import custom data from GitHub (considering you have configured the right scopes and possibly a Custom User model to store these fields).</p> <p>For example, you can use the following code to retrieve repository projects:</p> <pre><code># settings.py\n\nGITHUB_SSO_SAVE_ACCESS_TOKEN = True  # You will need this token\nGITHUB_SSO_PRE_LOGIN_CALLBACK = \"hooks.pre_login_user\"\nGITHUB_SSO_SCOPES = [\n    \"read:user\",\n    \"user:email\",\n    \"read:org\",\n    \"read:project\",  # &lt;- additional scope\n]\n</code></pre> <pre><code># myapp/hooks.py\nfrom github import Auth, Github\nfrom loguru import logger\n\n\ndef pre_login_user(user, request):\n    token = request.session.get(\"github_sso_access_token\")\n    if token:\n        # Request GitHub User Info\n        # To retrieve user's additional data, you need to add the respective scope,\n        # For example, \"read:project\" in settings GITHUB_SSO_SCOPES\n        auth = Auth.Token(token)\n        g = Github(auth=auth)\n        github_user = g.get_user()\n        project_info = github_user.get_repos()[0].get_projects()\n        logger.debug(f\"Updating User Data with GitHub Project Info: {project_info}\")\n</code></pre>"},{"location":"callback/","title":"Get your Callback URI","text":"<p>The callback URL is the URL where your GitHub will redirect the user after the authentication process. This URL must be registered in your GitHub OAuth App.</p>"},{"location":"callback/#the-callback-uri","title":"The Callback URI","text":"<p>The callback URI is composed of <code>{scheme}://{netloc}/{path}/</code>, where the netloc is the domain name of your Django project, and the path is <code>/github_sso/callback/</code>. For example, if your Django project is hosted on <code>https://myproject.com</code>, then the callback URL will be <code>https://myproject.com/github_sso/callback/</code>.</p> <p>So, let's break each part of this URI:</p>"},{"location":"callback/#the-scheme","title":"The scheme","text":"<p>The scheme is the protocol used to access the URL. It can be <code>http</code> or <code>https</code>. Django-GitHub-SSO will select the same scheme used by the URL which shows to you the login page.</p> <p>For example, if you're running locally, like <code>http://localhost:8000/accounts/login</code>, then the callback URL scheme will be <code>http://</code>.</p> How about a Reverse-Proxy? <p>If you're running Django behind a reverse-proxy, please make sure you're passing the correct <code>X-Forwarded-Proto</code> header to the login request URL.</p>"},{"location":"callback/#the-netloc","title":"The NetLoc","text":"<p>The NetLoc is the domain of your Django project. It can be a dns name, or an IP address, including the Port, if needed. Some examples are: <code>example.com</code>, <code>localhost:8000</code>, <code>api.my-domain.com</code>, and so on. To find the correct netloc, Django-GitHub-SSO will check, in that order:</p> <ul> <li>If settings contain the variable <code>GITHUB_SSO_CALLBACK_DOMAIN</code>, it will use this value.</li> <li>If Sites Framework is active, it will use the domain field for the current site.</li> <li>The netloc found in the URL which shows you the login page.</li> </ul>"},{"location":"callback/#the-path","title":"The Path","text":"<p>The path is the path to the callback view. It will be always <code>/&lt;path in urls.py&gt;/callback/</code>.</p> <p>Remember when you add this to the <code>urls.py</code>?</p> <pre><code>from django.urls import include, path\n\nurlpatterns = [\n    # other urlpatterns...\n    path(\n        \"github_sso/\", include(\n            \"django_github_sso.urls\",\n            namespace=\"django_github_sso\"\n        )\n    ),\n]\n</code></pre> <p>The path starts with the <code>github_sso/</code> part. If you change this to <code>sso/</code> for example, your callback URL will change to <code>https://myproject.com/sso/callback/</code>.</p>"},{"location":"callback/#registering-the-uri","title":"Registering the URI","text":"<p>If you need to change your callback URL, navigate back to <code>https://github.com/organizations/&lt;YOUR ORGANIZATION&gt;/settings/applications</code>, change the field <code>Authorization callback URL</code> and click <code>Update Application</code>.</p> <p></p> <p>Do not forget the trailing slash</p> <p>Many errors on this step are caused by forgetting the trailing slash:</p> <ul> <li>Good: <code>http://localhost:8000/github_sso/callback/</code></li> <li>Bad: <code>http://localhost:8000/github_sso/callback</code></li> </ul> <p>In the next step, we will configure Django-GitHub-SSO to auto create the Users.</p>"},{"location":"customize/","title":"Customizing the Login Page","text":"<p>Below, you can find some tips on how to customize the login page.</p>"},{"location":"customize/#hiding-the-login-form","title":"Hiding the Login Form","text":"<p>If you want to show only the GitHub Login button, you can hide the login form using the <code>SSO_SHOW_FORM_ON_ADMIN_PAGE</code> setting.</p> <pre><code># settings.py\n\nSSO_SHOW_FORM_ON_ADMIN_PAGE = False\n</code></pre>"},{"location":"customize/#customizing-the-login-button","title":"Customizing the Login button","text":"<p>Customizing the Login button is very simple. For the logo and text change is straightforward, just inform the new values. For the style, you can override the css file.</p>"},{"location":"customize/#the-button-logo","title":"The button logo","text":"<p>To change the logo, use the <code>GITHUB_SSO_BUTTON_LOGO</code> setting.</p> <pre><code># settings.py\nGITHUB_SSO_LOGO_URL = \"https://example.com/logo.png\"\n</code></pre>"},{"location":"customize/#the-button-text","title":"The button text","text":"<p>To change the text, use the <code>GITHUB_SSO_BUTTON_TEXT</code> setting.</p> <pre><code># settings.py\n\nGITHUB_SSO_TEXT = \"New login message\"\n</code></pre>"},{"location":"customize/#the-button-style","title":"The button style","text":"<p>The login button css style is located at <code>static/django_github_sso/github_button.css</code>. You can override this file as per Django static files documentation.</p>"},{"location":"customize/#an-example","title":"An example","text":"<pre><code># settings.py\n\nGITHUB_SSO_TEXT = \"Login using GitHub Org\"\n</code></pre> <pre><code>/* static/django_github_sso/github_button.css */\n\n/* other css... */\n\n.github-login-btn {\n    background-color: #40758f;\n    border: 1px solid #40758f;\n    padding: 1px;\n    margin-bottom: 10px;\n    width: 100%;\n    height: 28px;\n    display: flex;\n}\n</code></pre> <p>The result:</p> <p></p>"},{"location":"how/","title":"How Django GitHub SSO works?","text":""},{"location":"how/#current-flow","title":"Current Flow","text":"<ol> <li> <p>First, the user is redirected to the Django login page. If settings <code>GITHUB_SSO_ENABLED</code> is True, the \"Login with GitHub\" button will be added to a default form.</p> </li> <li> <p>On click, Django-GitHub-SSO will add, in a anonymous request session, the <code>sso_next_url</code> and GitHub Auth info. This data will expire in 10 minutes. Then user will be redirected to GitHub login page.</p> <p>Using Request Anonymous session</p> <p>If you make any actions which change or destroy this session, like restart django, clear cookies or change browsers, the login will fail, and you can see the message \"State Mismatched. Time expired?\" in the next time you log in again.</p> </li> <li> <p>On callback, Django-GitHub-SSO will check <code>code</code> and <code>state</code> received. If they are valid, GitHub's UserInfo will be retrieved. If the user is already registered in Django, the user will be logged in.</p> </li> <li> <p>Otherwise, the user will be created and logged in, if his email domain, matches one of the <code>GITHUB_SSO_ALLOWABLE_DOMAINS</code>. You can disable the auto-creation setting <code>GITHUB_SSO_AUTO_CREATE_USERS</code> to False.</p> </li> <li> <p>On creation only, this user can be set to the<code>staff</code> or <code>superuser</code> status, if his email are in <code>GITHUB_SSO_STAFF_LIST</code> or <code>GITHUB_SSO_SUPERUSER_LIST</code> respectively. Please note if you add an email to one of these lists, the email domain must be added to <code>GITHUB_SSO_ALLOWABLE_DOMAINS</code>too.</p> </li> <li> <p>This authenticated session will expire in 1 hour, or the time defined, in seconds, in <code>GITHUB_SSO_SESSION_COOKIE_AGE</code>.</p> </li> <li> <p>If login fails, you will be redirected to route defined in <code>GOOGLE_SSO_LOGIN_FAILED_URL</code> (default: <code>admin:index</code>) which will use Django Messaging system to show the error message.</p> </li> <li> <p>If login succeeds, the user will be redirected to the <code>next_path</code> saved in the anonymous session, or to the route defined in <code>GOOGLE_SSO_NEXT_URL</code> (default: <code>admin:index</code>) as a fallback.</p> </li> </ol>"},{"location":"model/","title":"Getting GitHub info","text":""},{"location":"model/#the-user-model","title":"The User model","text":"<p>Django GitHub SSO saves in the database the following information from GitHub, using current <code>User</code> model:</p> <ul> <li><code>email</code>: The primary verified email address of the user.</li> <li><code>first_name</code>: The first name of the user.</li> <li><code>last_name</code>: The last name of the user.</li> <li><code>username</code>: The primary verified email address of the user</li> <li><code>password</code>: An unusable password, generated using <code>get_unusable_password()</code> from Django.</li> </ul> <p>Getting data on code is straightforward:</p> <pre><code>from django.contrib.auth.decorators import login_required\nfrom django.http import JsonResponse, HttpRequest\n\n@login_required\ndef retrieve_user_data(request: HttpRequest) -&gt; JsonResponse:\n    user = request.user\n    return JsonResponse({\n        \"email\": user.email,\n        \"first_name\": user.first_name,\n        \"last_name\": user.last_name,\n        \"username\": user.username,\n    })\n</code></pre>"},{"location":"model/#the-githubssouser-model","title":"The GitHubSSOUser model","text":"<p>Also, on the <code>GitHubSSOUser</code> model, it saves the following information:</p> <ul> <li><code>github_id</code>: The internal GitHub user ID.</li> <li><code>picture_url</code>: The GitHub user picture URL.</li> <li><code>user_name</code>: The public GitHub user ID.</li> </ul> <p>This is a one-to-one relationship with the <code>User</code> model, so you can access this data using the <code>githubssouser</code> reverse relation attribute:</p> <pre><code>from django.contrib.auth.decorators import login_required\nfrom django.http import JsonResponse, HttpRequest\n\n@login_required\ndef retrieve_user_data(request: HttpRequest) -&gt; JsonResponse:\n    user = request.user\n    return JsonResponse({\n        \"email\": user.email,\n        \"first_name\": user.first_name,\n        \"last_name\": user.last_name,\n        \"username\": user.username,\n        \"github_id\": user.githubssouser.github_id,\n        \"picture_url\": user.githubssouser.picture_url,\n        \"user_name\": user.githubssouser.user_name,\n    })\n</code></pre> <p>You can also import the model directly, like this:</p> <pre><code>from django_github_sso.models import GitHubSSOUser\n\ngithub_info = GitHubSSOUser.objects.get(user=user)\n</code></pre>"},{"location":"model/#about-github-scopes","title":"About GitHub Scopes","text":"<p>To retrieve this data, Django GitHub SSO uses the following scope from Scopes for OAuth apps:</p> <pre><code>GITHUB_SSO_SCOPES = [  # GitHub default scope\n   \"read:user\", \"user:email\", \"read:org\"\n]\n</code></pre> <p>You can change this scopes overriding the <code>GITHUB_SSO_SCOPES</code> setting in your <code>settings.py</code> file. But if you ask the user to authorize more scopes, this plugin will not save this additional data in the database. You will need to implement your own logic to save this data, calling GitHub again. You can see an example here.</p> <p>The main goal here is simplicity</p> <p>The main goal of this plugin is to be simple to use as possible. But it is important to ask the user once for the scopes. That's why this plugin permits you to change the scopes, but will not save the additional data from it.</p>"},{"location":"model/#the-access-token","title":"The Access Token","text":"<p>To make login possible, Django GitHub SSO needs to get an access token from GitHub. This token is used to retrieve User info to get or create the user in the database. If you need this access token, you can get it inside the User Request Session, like this:</p> <pre><code>from django.contrib.auth.decorators import login_required\nfrom django.http import JsonResponse, HttpRequest\n\n@login_required\ndef retrieve_user_data(request: HttpRequest) -&gt; JsonResponse:\n    user = request.user\n    return JsonResponse({\n        \"email\": user.email,\n        \"first_name\": user.first_name,\n        \"last_name\": user.last_name,\n        \"username\": user.username,\n        \"github_id\": user.githubssouser.github_id,\n        \"picture_url\": user.githubssouser.picture_url,\n        \"user_name\": user.githubssouser.user_name,\n        \"access_token\": request.session[\"github_sso_access_token\"],\n    })\n</code></pre> <p>Saving the Access Token in User Session is disabled, by default, to avoid security issues. If you need to enable it, you can set the configuration <code>GITHUB_SSO_SAVE_ACCESS_TOKEN</code> to <code>True</code> in your <code>settings.py</code> file. Please make sure you understand how to secure your cookies before enabling this option.</p>"},{"location":"multiple/","title":"Using Multiple Social Logins","text":"<p>A special advanced case is when you need to login from multiple social providers. In this case, each provider will have its own package which you need to install and configure:</p> <ul> <li>Django Google SSO</li> <li>Django Microsoft SSO</li> <li>Django GitHub SSO</li> </ul>"},{"location":"multiple/#install-the-packages","title":"Install the Packages","text":"<p>Install the packages you need:</p> <pre><code>pip install django-google-sso django-microsoft-sso django-github-sso\n\n# Optionally install Stela to handle .env files\npip install stela\n</code></pre>"},{"location":"multiple/#add-package-to-django-project","title":"Add Package to Django Project","text":"<p>To add this package in your Django Project, please modify the <code>INSTALLED_APPS</code> in your <code>settings.py</code>:</p> <pre><code># settings.py\n\nINSTALLED_APPS = [\n    # other django apps\n    \"django.contrib.messages\",  # Need for Auth messages\n    \"django_github_sso\",  # Will show as first button in login page\n    \"django_google_sso\",\n    \"django_microsoft_sso\",\n]\n</code></pre> <p>Order matters</p> <p>The first package on list will be the first button in the login page.</p>"},{"location":"multiple/#add-secrets-to-env-file","title":"Add secrets to env file","text":"<pre><code># .env\nGOOGLE_SSO_CLIENT_ID=999999999999-xxxxxxxxx.apps.googleusercontent.com\nGOOGLE_SSO_CLIENT_SECRET=xxxxxx\nGOOGLE_SSO_PROJECT_ID=999999999999\n\nMICROSOFT_SSO_APPLICATION_ID=FOO\nMICROSOFT_SSO_CLIENT_SECRET=BAZ\n\nGITHUB_SSO_CLIENT_ID=BAR\nGITHUB_SSO_CLIENT_SECRET=FOOBAR\n</code></pre>"},{"location":"multiple/#setup-django-urls","title":"Setup Django URLs","text":"<p>Add the URLs of each provider to your <code>urls.py</code> file:</p> <pre><code>from django.urls import include, path\n\n\nurlpatterns += [\n    path(\n        \"github_sso/\",\n        include(\"django_google_sso.urls\", namespace=\"django_github_sso\"),\n    ),\n    path(\n        \"google_sso/\",\n        include(\"django_github_sso.urls\", namespace=\"django_google_sso\"),\n    ),\n        path(\n        \"microsoft_sso/\",\n        include(\"django_github_sso.urls\", namespace=\"django_microsoft_sso\"),\n    ),\n]\n</code></pre>"},{"location":"multiple/#setup-django-settings","title":"Setup Django Settings","text":"<p>Add the settings of each provider to your <code>settings.py</code> file:</p> <pre><code># settings.py\nfrom stela import env\n\n# Django Microsoft SSO\nMICROSOFT_SSO_ENABLED = True\nMICROSOFT_SSO_APPLICATION_ID = env.MICROSOFT_SSO_APPLICATION_ID\nMICROSOFT_SSO_CLIENT_SECRET = env.MICROSOFT_SSO_CLIENT_SECRET\nMICROSOFT_SSO_ALLOWABLE_DOMAINS = [\"contoso.com\"]\n\n# Django Google SSO\nGOOGLE_SSO_ENABLED = True\nGOOGLE_SSO_CLIENT_ID = env.GOOGLE_SSO_CLIENT_ID\nGOOGLE_SSO_PROJECT_ID = env.GOOGLE_SSO_PROJECT_ID\nGOOGLE_SSO_CLIENT_SECRET = env.GOOGLE_SSO_CLIENT_SECRET\nGOOGLE_SSO_ALLOWABLE_DOMAINS = [\"contoso.net\"]\n\n# Django GitHub SSO\nGITHUB_SSO_ENABLED = True\nGITHUB_SSO_CLIENT_ID = env.GITHUB_SSO_CLIENT_ID\nGITHUB_SSO_CLIENT_SECRET = env.GITHUB_SSO_CLIENT_SECRET\nGITHUB_SSO_ALLOWABLE_ORGANIZATIONS = [\"contoso\"]\n</code></pre> <p>The login page will look like this:</p> <p></p> <p>You can hide the login form</p> <p>If you want to show only the SSO buttons, you can hide the login form using the <code>SSO_SHOW_FORM_ON_ADMIN_PAGE</code> setting.</p> <pre><code># settings.py\n\nSSO_SHOW_FORM_ON_ADMIN_PAGE = False\n</code></pre>"},{"location":"multiple/#the-django-e003w003-warning","title":"The Django E003/W003 Warning","text":"<p>If you are using both Django Google SSO and Django Microsoft SSO, you will get the following warning:</p> <pre><code>WARNINGS:\n?: (templates.E003) 'show_form' is used for multiple template tag modules: 'django_google_sso.templatetags.show_form', 'django_microsoft_sso.templatetags.show_form'\n?: (templates.E003) 'sso_tags' is used for multiple template tag modules: 'django_google_sso.templatetags.sso_tags', 'django_microsoft_sso.templatetags.sso_tags'\n</code></pre> <p>This is because both packages use the same template tags. To silence this warning, you can set the <code>SILENCED_SYSTEM_CHECKS</code> as per Django documentation:</p> <pre><code># settings.py\nSILENCED_SYSTEM_CHECKS = [\"templates.E003\"]\n</code></pre> <p>But if you need to check the templates, you can use the <code>SSO_USE_ALTERNATE_W003</code> setting to use an alternate template tag. This alternate check will run the original check, but will not raise the warning for the Django SSO packages. To use this alternate check, you need to set both the Django Silence Check and <code>SSO_USE_ALTERNATE_W003</code>:</p> <pre><code># settings.py\n\nSILENCED_SYSTEM_CHECKS = [\"templates.E003\"]  # Will silence the original check\nSSO_USE_ALTERNATE_W003 = True  # Will run alternate check\n</code></pre>"},{"location":"quick_setup/","title":"Quick Setup","text":""},{"location":"quick_setup/#setup-django-settings","title":"Setup Django Settings","text":"<p>To add this package in your Django Project, please modify the <code>INSTALLED_APPS</code> in your <code>settings.py</code>:</p> <pre><code># settings.py\n\nINSTALLED_APPS = [\n    # other django apps\n    \"django.contrib.messages\",  # Need for Auth messages\n    \"django_github_sso\",  # Add django_github_sso\n]\n</code></pre>"},{"location":"quick_setup/#setup-github-oauth-app","title":"Setup GitHub OAuth App","text":"<p>Navigate to <code>https://github.com/organizations/&lt;YOUR ORGANIZATION&gt;/settings/applications</code>, then select or create a new <code>Org OAuth App</code>. In this tutorial we will create a new App.</p> <p>In the field Authorization callback URI add the address: <code>https://your-domain.com/github_sso/callback/</code> replacing <code>your-domain.com</code> with your real domain (and Port). For example, if you're running locally, you can use <code>http://localhost:8000/github_sso/callback/</code>.</p> <p>Do not forget the trailing slash!</p> <p></p> <p>With this, you can retrieve your <code>Client ID</code>. For the <code>Client Secret</code> please generate a new secret clicking on button <code>Generate a new client secret</code>:</p> <p></p>"},{"location":"quick_setup/#configuring-your-django-project","title":"Configuring your Django Project","text":"<p>After that, add the credentials in your <code>settings.py</code> file:</p> <pre><code># settings.py\nGITHUB_SSO_CLIENT_ID = \"your Application (client) Id here\"\nGITHUB_SSO_CLIENT_SECRET = \"your client secret value here\"\n</code></pre> <p>Don't commit this info in your repository. This permits you to have different credentials for each environment and mitigates security breaches. That's why we recommend you to use environment variables to store this info. To read this data, we recommend you to install and use a Twelve-factor compatible library in your project.</p> <p>For example, you can use our project Stela to load the environment variables from a <code>.env.local</code> file, like this:</p> <pre><code># .env.local\nGITHUB_SSO_CLIENT_ID=\"your Application (client) Id here\"\nGITHUB_SSO_CLIENT_SECRET=\"your client secret value here\"\n</code></pre> <pre><code># Django settings.py\nfrom stela import env\n\nGITHUB_SSO_CLIENT_ID = env.GITHUB_SSO_CLIENT_ID\nGITHUB_SSO_CLIENT_SECRET = env.GITHUB_SSO_CLIENT_SECRET\n</code></pre> <p>But in fact, you can use any library you want, like django-environ, django-constance, python-dotenv, etc...</p>"},{"location":"quick_setup/#setup-auto-create-users","title":"Setup Auto-Create Users","text":"<p>The next option is to set up the auto-create users from Django GitHub SSO. At least one of the following filters must be set:</p> <ul> <li><code>GITHUB_SSO_ALLOWABLE_DOMAINS</code>: will check against user's primary email</li> <li><code>GITHUB_SSO_ALLOWABLE_ORGS</code>: user needs to be a member of all orgs listed</li> <li><code>GITHUB_SSO_NEEDED_REPOS</code>: user needs to be a member of all repos listed</li> </ul> <p>Any combination of these filters can be used.</p> <pre><code># settings.py\n\nGITHUB_SSO_ALLOWABLE_DOMAINS = [\"example.com\"]  # will check against user's primary email\nGITHUB_SSO_ALLOWABLE_ORGS = [\"example\"]  # user needs to be a member of all orgs listed\nGITHUB_SSO_NEEDED_REPOS = [\"example/example-repo\"]  # user needs to be a member of all repos listed\n</code></pre> <p>If the GitHub user is invalid, the user will be redirected to the login page.</p> How can I  allow any GitHub user in my Django Admin? <p>To do this, use the option <code>GITHUB_SSO_ALLOW_ALL_USERS = True</code> in your <code>settings.py</code>. Please make sure you understand the security implications of this option.</p>"},{"location":"quick_setup/#setup-django-urls","title":"Setup Django URLs","text":"<p>And in your <code>urls.py</code> please add the Django-GitHub-SSO views:</p> <pre><code># urls.py\n\nfrom django.urls import include, path\n\nurlpatterns = [\n    # other urlpatterns...\n    path(\n        \"github_sso/\", include(\n            \"django_github_sso.urls\",\n            namespace=\"django_github_sso\"\n        )\n    ),\n]\n</code></pre>"},{"location":"quick_setup/#run-django-migrations","title":"Run Django migrations","text":"<p>Finally, run migrations</p> <pre><code>$ python manage.py migrate\n</code></pre> <p>And, that's it: Django GitHub SSO is ready for use. When you open the admin page, you will see the \"Login with GitHub\" button:</p> Light ModeDark Mode <p></p> <p></p> How about Django Admin skins, like Grappelli? <p>Django GitHub SSO will works with any Django Admin skin which calls the original Django login template, like Grappelli, Django Jazzmin, Django Admin Interface and Django Jet Reboot.</p> <p>If the skin uses his own login template, the \"Login with GitHub\" button will not be displayed.</p> <p>For the next pages, let's see each one of these steps with more details.</p>"},{"location":"settings/","title":"All Django Settings options","text":"Setting Description <code>GITHUB_SSO_ACCEPT_OUTSIDE_COLLABORATORS</code> Accept outside collaborators. Default: <code>False</code> <code>GITHUB_SSO_ALLOW_ALL_USERS</code> Explicity allow all users. Default: <code>False</code> <code>GITHUB_SSO_ALLOWABLE_DOMAINS</code> List of domains that will be allowed to create users. Default: <code>[]</code> <code>GITHUB_SSO_ALLOWABLE_ORGS</code> List of organizations that will be allowed to create users. Default: <code>[]</code> <code>GITHUB_SSO_ALWAYS_UPDATE_USER_DATA</code> If true, update default user info from GitHub data at every login. This will also make their password unusable. Otherwise, all of this happens only on create. Default: <code>False</code> <code>GITHUB_SSO_AUTHENTICATION_BACKEND</code> The authentication backend to use.  Default: <code>None</code> <code>GITHUB_SSO_AUTO_CREATE_FIRST_SUPERUSER</code> If True, the first user that logs in will be created as superuser if no superuser exists in the database at all. Default: <code>False</code> <code>GITHUB_SSO_AUTO_CREATE_USERS</code> Enable or disable the auto-create users feature. Default: <code>True</code> <code>GITHUB_SSO_CALLBACK_DOMAIN</code> The netloc to be used on Callback URI. Default: <code>None</code> <code>GITHUB_SSO_CHECK_ONLY_PRIMARY_EMAIL</code> Check only primary email. Default: <code>False</code> <code>GITHUB_SSO_CLIENT_ID</code> The GitHub OAuth 2.0 Web Application Client ID. Default: <code>None</code> <code>GITHUB_SSO_CLIENT_SECRET</code> The GitHub OAuth 2.0 Web Application Client Secret. Default: <code>None</code> <code>GITHUB_SSO_ENABLED</code> Enable or disable the plugin. Default: <code>True</code> <code>GITHUB_SSO_LOGIN_FAILED_URL</code> The named url path that the user will be redirected to if an authentication error is encountered. Default: <code>admin:index</code> <code>GITHUB_SSO_LOGO_URL</code> The URL of the logo to be used on the login button. Default: <code>https://github.githubassets.com/assets/GitHub-Mark-ea2971cee799.png</code> <code>GITHUB_SSO_NEEDED_REPOS</code> List of repositories the user needs to be member to authorize login. Default: <code>[]</code> <code>GITHUB_SSO_NEXT_URL</code> The named url path that the user will be redirected if there is no next url after successful authentication. Default: <code>admin:index</code> <code>GITHUB_SSO_PRE_LOGIN_CALLBACK</code> Callable for processing pre-login logic. Default: <code>django_github_sso.hooks.pre_login_user</code> <code>GITHUB_SSO_SAVE_ACCESS_TOKEN</code> Save the access token in the session. Default: <code>False</code> <code>GITHUB_SSO_SCOPES</code> The GitHub OAuth 2.0 Scopes. Default: <code>[\"read:user\", \"user:email\", \"read:org\"]</code> <code>GITHUB_SSO_SESSION_COOKIE_AGE</code> The age of the session cookie in seconds. Default: <code>3600</code> <code>GITHUB_SSO_SHOW_ADDITIONAL_ERROR_MESSAGES</code> Show additional error messages in django message system when authentication fails. Default: <code>False</code> <code>GITHUB_SSO_STAFF_LIST</code> List of emails that will be created as staff. Default: <code>[]</code> <code>GITHUB_SSO_SUPERUSER_LIST</code> List of emails that will be created as superuser. Default: <code>[]</code> <code>GITHUB_SSO_TEXT</code> The text to be used on the login button. Default: <code>Sign in with GitHub</code> <code>GITHUB_SSO_TIMEOUT</code> The timeout in seconds for the GitHub SSO authentication returns info, in minutes. Default: <code>10</code> <code>GITHUB_SSO_UNIQUE_EMAIL</code> When get or create a new user, check if the email already exists. Default: <code>False</code> <code>SSO_SHOW_FORM_ON_ADMIN_PAGE</code> Show the form on the admin page. Default: <code>True</code> <code>SSO_USE_ALTERNATE_W003</code> Use alternate W003 warning. You need to silence original templates.E003 warning. Default: <code>False</code>"},{"location":"thanks/","title":"Thank you","text":"<p>Thank you for using this project. And for all the appreciation, patience and support.</p> <p>I really hope this project can make your life a little easier.</p> <p>Please feel free to check our other projects:</p> <ul> <li>stela: Easily manage project settings and secrets in any python project.</li> <li>django-google-sso: A Django app to enable Single Sign-On with Google Accounts.</li> <li>django-microsoft-sso: A Django app to enable Single Sign-On with Microsoft 365 Accounts.</li> <li>django-github-sso: A Django app to enable Single Sign-On with GitHub Accounts.</li> </ul>"},{"location":"thanks/#donating","title":"Donating","text":"<p>If you like to finance this project, please consider donating:</p> <p></p>"},{"location":"troubleshooting/","title":"Troubleshooting Guide","text":""},{"location":"troubleshooting/#common-errors","title":"Common errors:","text":"Admin Message: State Mismatched. Time expired? <p>This error occurs when the user is redirected to the Google login page and then returns to the Django login page but original state are not found. Please check if the browser has the anonymous session created by Django.</p> Admin Message: User not allowed to login <p>Please check your filters, some combinations can filter all users. Use the option <code>GITHUB_SSO_SHOW_ADDITIONAL_ERROR_MESSAGES</code> to show additional error messages in django message system when authentication fails.</p>"},{"location":"troubleshooting/#example-app","title":"Example App","text":"<p>To test this library please check the <code>Example App</code> provided here.</p>"},{"location":"troubleshooting/#not-working","title":"Not working?","text":"<p>Don't panic. Get a towel and, please, open an issue.</p>"},{"location":"urls/","title":"Setup Django URLs","text":"<p>The base configuration for Django URLs is the same we have described as before: <pre><code># urls.py\n\nfrom django.urls import include, path\n\nurlpatterns = [\n    # other urlpatterns...\n    path(\n        \"github_sso/\", include(\n            \"django_github_sso.urls\",\n            namespace=\"django_github_sso\"\n        )\n    ),\n]\n</code></pre> You can change the initial Path - <code>github_sso/</code> - to whatever you want - just remember to change it in your GitHub OAuth configuration.</p>"},{"location":"urls/#overriding-the-login-view-or-path","title":"Overriding the Login view or Path","text":"<p>If you need to override the login view, or just the path, please add on the new view/class the Django SSO Admin login template:</p> <pre><code>from django.contrib.auth.views import LoginView\nfrom django.urls import path\n\nurlpatterns = [\n    # other urlpatterns...\n    path(\n        \"accounts/login/\",\n        LoginView.as_view(\n            # The modified form with GitHub button\n            template_name=\"github_sso/login.html\"\n        ),\n    ),\n]\n</code></pre> <p>or you can use a complete custom class:</p> <pre><code>from django.contrib.auth.views import LoginView\n\n\nclass MyLoginView(LoginView):\n    template_name = \"github_sso/login.html\"\n</code></pre>"},{"location":"users/","title":"Auto Creating Users","text":"<p>Django GitHub SSO can automatically create users from GitHub SSO authentication. To enable this feature, you need to setup at least one of the available user filters in your <code>settings.py</code>. Let's review each one of them.</p>"},{"location":"users/#available-filters","title":"Available Filters","text":""},{"location":"users/#allowable-repositories","title":"Allowable Repositories","text":"<p>If you want to allow any GitHub users that are members of a specific repository, you can set the <code>GITHUB_SSO_ALLOWABLE_REPOS</code></p> <pre><code># settings.py\n\nGITHUB_SSO_ALLOWABLE_REPOS = [\"my-company/my-repo\"]\n</code></pre> <p>This is the simpler filter, if the user is a member of the repository, it will be allowed to login.</p> <p>Always use repository's full name</p> <p>Please remember to use the full name of the repository, including the organization name. Example: <code>my-company/my-repo</code></p>"},{"location":"users/#allowable-organizations","title":"Allowable Organizations","text":"<p>If you want to allow any GitHub users that are members of a specific organization, you can set the <code>GITHUB_SSO_ALLOWABLE_ORGS</code></p> <pre><code># settings.py\n\nGITHUB_SSO_ALLOWABLE_ORGS = [\"my-company\"]\n</code></pre> <p>User must be member, not outside collaborator, for each org listed. To allow outside collaborators, you can set the <code>GITHUB_SSO_ALLOW_OUTSIDE_COLLABORATORS</code> setting to <code>True</code>:</p> <pre><code># settings.py\n\nGITHUB_SSO_ALLOWABLE_ORGS = [\"my-company\"]\nGITHUB_SSO_ALLOW_OUTSIDE_COLLABORATORS = True\n</code></pre>"},{"location":"users/#allowable-domains-for-emails","title":"Allowable Domains for Emails","text":"<p>If you want to allow any GitHub users with a specific email domain, you can set the <code>GITHUB_SSO_ALLOWABLE_DOMAINS</code> setting:</p> <pre><code># settings.py\nGITHUB_SSO_ALLOWABLE_DOMAINS = [\"my-company.com\"]\n</code></pre> <p>In this example, any users with a <code>my-company.com</code> primary email will be allowed to login. On GitHub, a user can have multiple emails, but only one of them is the primary email. This is the email that will be used for the filter. If you want to check all user emails with the allowable domains, you can set the <code>GITHUB_SSO_CHECK_ONLY_PRIMARY_EMAIL</code> setting to <code>False</code>:</p> <pre><code># settings.py\n\nGITHUB_SSO_ALLOWABLE_DOMAINS = [\"my-company.com\"]\nGITHUB_SSO_CHECK_ONLY_PRIMARY_EMAIL = False\n</code></pre> <p>Django GitHub SSO will always check only against verified emails from the user.</p> What happens if user has more than one valid email? <p>If the user has more than one valid verified email - for example <code>user@my-company.com</code> and <code>full.name@my-company.com</code>, the first one will be used.</p>"},{"location":"users/#combining-filters","title":"Combining Filters","text":"<p>You can combine the filters to allow only users that match all filters. Some examples:</p> <pre><code># settings.py\n\n# Allow only users that have a verified email with the my-company.com domain\nGITHUB_SSO_ALLOWABLE_DOMAINS = [\"my-company.com\"]\nGITHUB_SSO_CHECK_ONLY_PRIMARY_EMAIL = False\n</code></pre> <pre><code># Allow only users that are members of the my-company organization\n# and have a primary email with the my-company.com domain\n# and are members of the my-repo repository\nGITHUB_SSO_ALLOWABLE_ORGS = [\"my-company\"]\nGITHUB_SSO_ALLOWABLE_DOMAINS = [\"my-company.com\"]\nGITHUB_SSO_ALLOWABLE_REPOS = [\"my-company/my-repo\"]\n</code></pre> <pre><code># Allow only users that are members of the my-company organization\n# but accept any email domain and outside collaborators\nGITHUB_SSO_ALLOWABLE_ORGS = [\"my-company\"]\nGITHUB_SSO_ALLOW_OUTSIDE_COLLABORATORS = True\n</code></pre> <p>Allowing any GitHub user in your Django Admin</p> <ul> <li>You need to set the option <code>GITHUB_SSO_ALLOW_ALL_USERS=True</code> to allow any GitHub user in your Django Admin.</li> <li>If you set any filters, this option will be ignored.</li> <li>Please make sure you understand the security implications of this option.</li> </ul>"},{"location":"users/#disabling-the-auto-create-users","title":"Disabling the auto-create users","text":"<p>You can disable the auto-create users feature by setting the <code>GITHUB_SSO_AUTO_CREATE_USERS</code> setting to <code>False</code>:</p> <pre><code>GITHUB_SSO_AUTO_CREATE_USERS = False\n</code></pre> <p>You can also disable the plugin completely:</p> <pre><code>GITHUB_SSO_ENABLED = False\n</code></pre>"},{"location":"users/#giving-permissions-to-auto-created-users","title":"Giving Permissions to Auto-Created Users","text":"<p>If you are using the auto-create users feature, you can give permissions to the users that are created automatically. To do this, you can set the following options in your <code>settings.py</code>:</p> <pre><code># List of emails or github user_names that will be created as staff\nGITHUB_SSO_STAFF_LIST = [\"my-email@my-company.com\", \"my-user-name\"]\n\n# List of emails or github user_names that will be created as superuser\nGITHUB_SSO_SUPERUSER_LIST = [\"another-email@my-company.com\" \"another-user-name\"]\n</code></pre>"},{"location":"users/#if-true-the-first-user-that-checks-in-will-be-created-as-superuser","title":"If True, the first user that checks in will be created as superuser","text":""},{"location":"users/#if-no-superuser-exists-in-the-database-at-all","title":"if no superuser exists in the database at all","text":"<p>GITHUB_SSO_AUTO_CREATE_FIRST_SUPERUSER = True <pre><code>!!! tip \"Which Email will be used to save this user on Django?\"\n    The primary email will be used. If the option `GITHUB_SSO_CHECK_ONLY_PRIMARY_EMAIL` is `False`\n    and  `GITHUB_SSO_ALLOWABLE_DOMAINS` is `True` the first valid email will be used.\n\n## Fine-tuning users before login\n\nIf you need to do some processing _after_ user is created or retrieved,\nbut _before_ the user is logged in, you can set the\n`GITHUB_SSO_PRE_LOGIN_CALLBACK` setting to import a custom function that will be called before the user is logged in.\nThis function will receive two arguments: the `user` and `request` objects.\n\n```python\n# myapp/hooks.py\ndef pre_login_user(user, request):\n    # Do something with the user\n    pass\n\n# settings.py\nGITHUB_SSO_PRE_LOGIN_CALLBACK = \"myapp.hooks.pre_login_user\"\n</code></pre></p> <p>Please remember this function will be invoked only if a user exists, and if it is active. In other words, if the user is eligible for login.</p> <p>Be careful with these options</p> <p>The idea here is to make your life easier, especially when testing. But if you are not careful, you can give permissions to users that you don't want, or even worse, you can give permissions to users that you don't know. So, please, be careful with these options.</p> <p>For the last step, we will look at the Django URLs.</p>"}]}